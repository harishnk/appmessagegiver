{"ts":1363486828133,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*!\n * Module dependencies.\n */\n\nvar utils = require('./utils')\n  , merge = utils.merge\n  , Promise = require('./promise')\n  , Document = require('./document')\n  , Types = require('./schema/index')\n  , inGroupsOf = utils.inGroupsOf\n  , tick = utils.tick\n  , QueryStream = require('./querystream')\n  , ReadPref = require('mongodb').ReadPreference\n\n/**\n * Query constructor used for building queries.\n *\n * ####Example:\n *\n *     var query = Model.find();\n *     query.where('age').gte(21).exec(callback);\n *\n * @param {Object} criteria\n * @param {Object} options\n * @api public\n */\n\nfunction Query (criteria, options) {\n  this.setOptions(options, true);\n  this._conditions = {};\n  this._updateArg = {};\n  this._fields = undefined;\n  if (criteria) this.find(criteria);\n}\n\n/**\n * Sets query options.\n *\n * ####Options:\n *\n * - [tailable](http://www.mongodb.org/display/DOCS/Tailable+Cursors) *\n * - [sort](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsort(\\)%7D%7D) *\n * - [limit](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D) *\n * - [skip](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D) *\n * - [maxscan](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24maxScan) *\n * - [batchSize](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D) *\n * - [comment](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment) *\n * - [snapshot](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D) *\n * - [hint](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint) *\n * - [slaveOk](http://docs.mongodb.org/manual/applications/replication/#read-preference) *\n * - [lean](./api.html#query_Query-lean) *\n * - [safe](http://www.mongodb.org/display/DOCS/getLastError+Command)\n *\n * _* denotes a query helper method is also available_\n *\n * @param {Object} options\n * @api public\n */\n\nQuery.prototype.setOptions = function (options, overwrite) {\n  // overwrite is internal use only\n  if (overwrite) {\n    options = this.options = options || {};\n    this.safe = options.safe\n\n    // normalize population options\n    var pop = this.options.populate;\n    this.options.populate = {};\n\n    if (pop && Array.isArray(pop)) {\n      for (var i = 0, l = pop.length; i < l; i++) {\n        this.options.populate[pop[i]] = {};\n      }\n    }\n\n    return this;\n  }\n\n  if (!(options && 'Object' == options.constructor.name))\n    return this;\n\n  if ('safe' in options)\n    this.safe = options.safe;\n\n  // set arbitrary options\n  var methods = Object.keys(options)\n    , i = methods.length\n    , method\n\n  while (i--) {\n    method = methods[i];\n\n    // use methods if exist (safer option manipulation)\n    if ('function' == typeof this[method]) {\n      var args = Array.isArray(options[method])\n        ? options[method]\n        : [options[method]];\n      this[method].apply(this, args)\n    } else {\n      this.options[method] = options[method];\n    }\n  }\n  return this;\n}\n\n/**\n * Binds this query to a model.\n *\n * @param {Model} model the model to which the query is bound\n * @param {String} op the operation to execute\n * @param {Object} updateArg used in update methods\n * @return {Query}\n * @api private\n */\n\nQuery.prototype.bind = function bind (model, op, updateArg) {\n  this.model = model;\n  this.op = op;\n\n  if (model._mapreduce) this.options.lean = true;\n\n  if (op == 'update' || op == 'findOneAndUpdate') {\n    merge(this._updateArg, updateArg || {});\n  }\n\n  return this;\n};\n\n/**\n * Executes the query\n *\n * ####Examples\n *\n *     query.exec();\n *     query.exec(callback);\n *     query.exec('update');\n *     query.exec('find', callback);\n *\n * @param {String|Function} [operation]\n * @param {Function} [callback]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.exec = function exec (op, callback) {\n  var promise = new Promise();\n\n  switch (typeof op) {\n    case 'function':\n      callback = op;\n      op = null;\n      break;\n    case 'string':\n      this.op = op;\n      break;\n  }\n\n  if (callback) promise.addBack(callback);\n\n  if (!this.op) {\n    promise.complete();\n    return promise;\n  }\n\n  if ('update' == this.op) {\n    this[this.op](this._updateArg, promise.resolve.bind(promise));\n    return promise;\n  }\n\n  if ('distinct' == this.op) {\n    this.distinct(this._distinctArg, promise.resolve.bind(promise));\n    return promise;\n  }\n\n  this[this.op](promise.resolve.bind(promise));\n  return promise;\n};\n\n/**\n * Finds documents.\n *\n * When no `callback` is passed, the query is not executed.\n *\n * ####Example\n *\n *     query.find({ name: 'Los Pollos Hermanos' }).find(callback)\n *\n * @param {Object} [criteria] mongodb selector\n * @param {Function} [callback]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.find = function (criteria, callback) {\n  this.op = 'find';\n  if ('function' === typeof criteria) {\n    callback = criteria;\n    criteria = {};\n  } else if (criteria instanceof Query) {\n    // TODO Merge options, too\n    merge(this._conditions, criteria._conditions);\n  } else if (criteria instanceof Document) {\n    merge(this._conditions, criteria.toObject());\n  } else if (criteria && 'Object' === criteria.constructor.name) {\n    merge(this._conditions, criteria);\n  }\n  if (!callback) return this;\n  return this.execFind(callback);\n};\n\n/**\n * Casts this query to the schema of `model`\n *\n * ####Note\n *\n * If `obj` is present, it is cast instead of this query.\n *\n * @param {Model} model\n * @param {Object} [obj]\n * @return {Object}\n * @api public\n */\n\nQuery.prototype.cast = function (model, obj) {\n  obj || (obj= this._conditions);\n\n  var schema = model.schema\n    , paths = Object.keys(obj)\n    , i = paths.length\n    , any$conditionals\n    , schematype\n    , nested\n    , path\n    , type\n    , val;\n\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n\n    if ('$or' === path || '$nor' === path || '$and' === path) {\n      var k = val.length\n        , orComponentQuery;\n\n      while (k--) {\n        orComponentQuery = new Query(val[k]);\n        orComponentQuery.cast(model);\n        val[k] = orComponentQuery._conditions;\n      }\n\n    } else if (path === '$where') {\n      type = typeof val;\n\n      if ('string' !== type && 'function' !== type) {\n        throw new Error(\"Must have a string or function for $where\");\n      }\n\n      if ('function' === type) {\n        obj[path] = val.toString();\n      }\n\n      continue;\n\n    } else {\n\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n\n      schematype = schema.path(path);\n\n      if (!schematype) {\n        // Handle potential embedded array queries\n        var split = path.split('.')\n          , j = split.length\n          , pathFirstHalf\n          , pathLastHalf\n          , remainingConds\n          , castingQuery;\n\n        // Find the part of the var path that is a path of the Schema\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n          if (schematype) break;\n        }\n\n        // If a substring of the input path resolves to an actual real path...\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.caster && schematype.caster.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n            castingQuery = new Query(remainingConds);\n            castingQuery.cast(schematype.caster);\n            obj[path] = castingQuery._conditions[pathLastHalf];\n          } else {\n            obj[path] = val;\n          }\n          continue;\n        }\n\n        if (utils.isObject(val)) {\n          // handle geo schemas that use object notation\n          // { loc: { long: Number, lat: Number }\n\n          var geo = val.$near ? '$near' :\n                    val.$nearSphere ? '$nearSphere' :\n                    val.$within ? '$within' : '';\n\n          if (!geo) {\n            continue;\n          }\n\n          var numbertype = new Types.Number('__QueryCasting__')\n          var value = val[geo];\n\n          if (val.$maxDistance) {\n            val.$maxDistance = numbertype.castForQuery(val.$maxDistance);\n          }\n\n          if ('$within' == geo) {\n            // find $center, $centerSphere, $box, $polygon\n            var withinType = value.$center || value.$centerSphere || value.$box || value.$polygon;\n            if (!withinType) {\n              throw new Error('Bad $within paramater: ' + JSON.stringify(val));\n            }\n\n            value = withinType;\n          }\n\n          ;(function _cast (val) {\n            if (Array.isArray(val)) {\n              val.forEach(function (item, i) {\n                if (Array.isArray(item) || utils.isObject(item)) {\n                  return _cast(item);\n                }\n                val[i] = numbertype.castForQuery(item);\n              });\n            } else {\n              var nearKeys= Object.keys(val);\n              var nearLen = nearKeys.length;\n              while (nearLen--) {\n                var nkey = nearKeys[nearLen];\n                var item = val[nkey];\n                if (Array.isArray(item) || utils.isObject(item)) {\n                  _cast(item);\n                  val[nkey] = item;\n                } else {\n                  val[nkey] = numbertype.castForQuery(item);\n                }\n              }\n            }\n          })(value);\n        }\n\n      } else if (val === null || val === undefined) {\n        continue;\n      } else if ('Object' === val.constructor.name) {\n\n        any$conditionals = Object.keys(val).some(function (k) {\n          return k.charAt(0) === '$' && k !== '$id' && k !== '$ref';\n        });\n\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQuery(val);\n        } else {\n\n          var ks = Object.keys(val)\n            , k = ks.length\n            , $cond;\n\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n\n            if ('$exists' === $cond) {\n              if ('boolean' !== typeof nested) {\n                throw new Error(\"$exists parameter must be Boolean\");\n              }\n              continue;\n            }\n\n            if ('$type' === $cond) {\n              if ('number' !== typeof nested) {\n                throw new Error(\"$type parameter must be Number\");\n              }\n              continue;\n            }\n\n            if ('$not' === $cond) {\n              this.cast(model, nested);\n            } else {\n              val[$cond] = schematype.castForQuery($cond, nested);\n            }\n          }\n        }\n      } else {\n        obj[path] = schematype.castForQuery(val);\n      }\n    }\n  }\n\n  return obj;\n};\n\n/**\n * Returns default options.\n * @param {Model} model\n * @api private\n */\n\nQuery.prototype._optionsForExec = function (model) {\n  var options = utils.clone(this.options, { retainKeyOrder: true });\n  delete options.populate;\n\n  if (!('safe' in options))\n    options.safe = model.schema.options.safe;\n\n  if (!('readPreference' in options) && model.schema.options.read)\n    options.readPreference = model.schema.options.read;\n\n  return options;\n};\n\n/**\n * Applies schematype selected options to this query.\n * @api private\n */\n\nQuery.prototype._applyPaths = function applyPaths () {\n  // determine if query is selecting or excluding fields\n\n  var fields = this._fields\n    , exclude\n    , keys\n    , ki\n\n  if (fields) {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    while (ki--) {\n      if ('+' == keys[ki][0]) continue;\n      exclude = 0 === fields[keys[ki]];\n      break;\n    }\n  }\n\n  // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n\n  var selected = []\n    , excluded = []\n    , seen = [];\n\n  analyzeSchema(this.model.schema);\n\n  switch (exclude) {\n    case true:\n      excluded.length && this.select('-' + excluded.join(' -'));\n      break;\n    case false:\n      selected.length && this.select(selected.join(' '));\n      break;\n    case undefined:\n      // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields\n      excluded.length && this.select('-' + excluded.join(' -'));\n      break;\n  }\n\n  return seen = excluded = selected = keys = fields = null;\n\n  function analyzeSchema (schema, prefix) {\n    prefix || (prefix = '');\n\n    // avoid recursion\n    if (~seen.indexOf(schema)) return;\n    seen.push(schema);\n\n    schema.eachPath(function (path, type) {\n      if (prefix) path = prefix + '.' + path;\n\n      // array of subdocs?\n      if (type.schema) {\n        analyzeSchema(type.schema, path);\n      }\n\n      analyzePath(path, type);\n    });\n  }\n\n  function analyzePath (path, type) {\n    if ('boolean' != typeof type.selected) return;\n\n    if (fields && ('+' + path) in fields) {\n      // forced inclusion\n      delete fields['+' + path];\n\n      // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n      if (false === exclude && keys.length > 1) {\n        fields[path] = 1;\n      }\n\n      return\n    };\n\n    ;(type.selected ? selected : excluded).push(path);\n  }\n}\n\n/**\n * Specifies a `$where` condition\n *\n * Use `$where` when you need to select documents using a JavaScript expression.\n *\n * ####Example\n *\n *     query.$where('this.comments.length > 10 || this.name.length > 5')\n *\n *     query.$where(function () {\n *       return this.comments.length > 10 || this.name.length > 5;\n *     })\n *\n * @param {String|Function} js javascript string or function\n * @return {Query} this\n * @memberOf Query\n * @method $where\n * @api public\n */\n\nQuery.prototype.$where = function (js) {\n  this._conditions['$where'] = js;\n  return this;\n};\n\n/**\n * Specifies a `path` for use with chaining.\n *\n * ####Example\n *\n *     // instead of writing:\n *     User.find({age: {$gte: 21, $lte: 65}}, callback);\n *\n *     // we can instead write:\n *     User.where('age').gte(21).lte(65);\n *\n *     // Moreover, you can also chain a bunch of these together:\n *\n *     User\n *     .where('age').gte(21).lte(65)\n *     .where('name', /^b/i)\n *     .where('friends').slice(10)\n *     .exec(callback)\n *\n * @param {String} [path]\n * @param {Object} [val]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.where = function (path, val) {\n  if (!arguments.length) return this;\n\n  if ('string' != typeof path) {\n    throw new TypeError('path must be a string');\n  }\n\n  this._currPath = path;\n\n  if (2 === arguments.length) {\n    this._conditions[path] = val;\n  }\n\n  return this;\n};\n\n/**\n * Specifies the complementary comparison value for paths specified with `where()`\n *\n * ####Example\n *\n *     User.where('age').equals(49);\n *\n *     // is the same as\n *\n *     User.where('age', 49);\n *\n * @param {Object} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.equals = function equals (val) {\n  var path = this._currPath;\n  if (!path) throw new Error('equals() must be used after where()');\n  this._conditions[path] = val;\n  return this;\n}\n\n/**\n * Specifies arguments for an `$or` condition.\n *\n * ####Example\n *\n *     query.or([{ color: 'red' }, { status: 'emergency' }])\n *\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.or = function or (array) {\n  var or = this._conditions.$or || (this._conditions.$or = []);\n  if (!Array.isArray(array)) array = [array];\n  or.push.apply(or, array);\n  return this;\n}\n\n/**\n * Specifies arguments for a `$nor` condition.\n *\n * ####Example\n *\n *     query.nor([{ color: 'green' }, { status: 'ok' }])\n *\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.nor = function nor (array) {\n  var nor = this._conditions.$nor || (this._conditions.$nor = []);\n  if (!Array.isArray(array)) array = [array];\n  nor.push.apply(nor, array);\n  return this;\n}\n\n/**\n * Specifies arguments for a `$and` condition.\n *\n * ####Example\n *\n *     query.and([{ color: 'green' }, { status: 'ok' }])\n *\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.and = function and (array) {\n  var and = this._conditions.$and || (this._conditions.$and = []);\n  if (!Array.isArray(array)) array = [array];\n  and.push.apply(and, array);\n  return this;\n}\n\n/**\n * Specifies a $gt query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * ####Example\n *\n *     Thing.find().where('age').gt(21)\n *\n *     // or\n *     Thing.find().gt('age', 21)\n *\n * @method gt\n * @memberOf Query\n * @param {String} path\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $gte query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method gte\n * @memberOf Query\n * @param {String} path\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $lt query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lt\n * @memberOf Query\n * @param {String} path\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $lte query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lte\n * @memberOf Query\n * @param {String} path\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $ne query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method ne\n * @memberOf Query\n * @param {String} path\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies an $in query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method in\n * @memberOf Query\n * @param {String} path\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies an $nin query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method nin\n * @memberOf Query\n * @param {String} path\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies an $all query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method all\n * @memberOf Query\n * @param {String} path\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies an $size query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method size\n * @memberOf Query\n * @param {String} path\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $regex query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method regex\n * @memberOf Query\n * @param {String} path\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $maxDistance query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method maxDistance\n * @memberOf Query\n * @param {String} path\n * @param {Number} val\n * @api public\n */\n\n/*!\n * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance\n *\n *     Thing.where('type').nin(array)\n */\n\n'gt gte lt lte ne in nin all regex size maxDistance'.split(' ').forEach(function ($conditional) {\n  Query.prototype[$conditional] = function (path, val) {\n    if (arguments.length === 1) {\n      val = path;\n      path = this._currPath\n    }\n    var conds = this._conditions[path] || (this._conditions[path] = {});\n    conds['$' + $conditional] = val;\n    return this;\n  };\n});\n\n/**\n * Specifies a `$near` condition\n *\n * @param {String} path\n * @param {Number} val\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\nQuery.prototype.near = function (path, val) {\n  if (arguments.length === 1) {\n    val = path;\n    path = this._currPath\n  } else if (arguments.length === 2 && !Array.isArray(val)) {\n    val = utils.args(arguments);\n    path = this._currPath;\n  } else if (arguments.length === 3) {\n    val = utils.args(arguments, 1);\n  }\n  var conds = this._conditions[path] || (this._conditions[path] = {});\n  conds.$near = val;\n  return this;\n}\n\n/**\n * Specifies a `$nearSphere` condition.\n *\n * @param {String} path\n * @param {Object} val\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\nQuery.prototype.nearSphere = function (path, val) {\n  if (arguments.length === 1) {\n    val = path;\n    path = this._currPath\n  } else if (arguments.length === 2 && !Array.isArray(val)) {\n    val = utils.args(arguments);\n    path = this._currPath;\n  } else if (arguments.length === 3) {\n    val = utils.args(arguments, 1);\n  }\n  var conds = this._conditions[path] || (this._conditions[path] = {});\n  conds.$nearSphere = val;\n  return this;\n}\n\n/**\n * Specifies a `$mod` condition\n *\n * @param {String} path\n * @param {Number} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.mod = function (path, val) {\n  if (arguments.length === 1) {\n    val = path;\n    path = this._currPath\n  } else if (arguments.length === 2 && !Array.isArray(val)) {\n    val = utils.args(arguments);\n    path = this._currPath;\n  } else if (arguments.length === 3) {\n    val = utils.args(arguments, 1);\n  }\n  var conds = this._conditions[path] || (this._conditions[path] = {});\n  conds.$mod = val;\n  return this;\n}\n\n/**\n * Specifies an `$exists` condition\n *\n * @param {String} path\n * @param {Number} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.exists = function (path, val) {\n  if (arguments.length === 0) {\n    path = this._currPath\n    val = true;\n  } else if (arguments.length === 1) {\n    if ('boolean' === typeof path) {\n      val = path;\n      path = this._currPath;\n    } else {\n      val = true;\n    }\n  }\n  var conds = this._conditions[path] || (this._conditions[path] = {});\n  conds['$exists'] = val;\n  return this;\n};\n\n/**\n * Specifies an `$elemMatch` condition\n *\n * ####Example\n *\n *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})\n *\n *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})\n *\n *     query.elemMatch('comment', function (elem) {\n *       elem.where('author').equals('autobot');\n *       elem.where('votes').gte(5);\n *     })\n *\n *     query.where('comment').elemMatch(function (elem) {\n *       elem.where('author').equals('autobot');\n *       elem.where('votes').gte(5);\n *     })\n *\n * @param {String|Object|Function} path\n * @param {Object|Function} criteria\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.elemMatch = function (path, criteria) {\n  var block;\n  if ('Object' === path.constructor.name) {\n    criteria = path;\n    path = this._currPath;\n  } else if ('function' === typeof path) {\n    block = path;\n    path = this._currPath;\n  } else if ('Object' === criteria.constructor.name) {\n  } else if ('function' === typeof criteria) {\n    block = criteria;\n  } else {\n    throw new Error(\"Argument error\");\n  }\n  var conds = this._conditions[path] || (this._conditions[path] = {});\n  if (block) {\n    criteria = new Query();\n    block(criteria);\n    conds['$elemMatch'] = criteria._conditions;\n  } else {\n    conds['$elemMatch'] = criteria;\n  }\n  return this;\n};\n\n// Spatial queries\n\n/**\n * Syntax sugar for expressive queries.\n *\n * ####Example\n *\n *     query.within.box()\n *     query.within.center()\n *\n * @property within\n * @memberOf Query\n * @return {Query} this\n * @api public\n */\n\nObject.defineProperty(Query.prototype, 'within', {\n  get: function () { return this }\n});\n\n/**\n * Specifies a $box condition\n *\n * ####Example\n *\n *     var lowerLeft = [40.73083, -73.99756]\n *     var upperRight= [40.741404,  -73.988135]\n *     query.where('loc').within.box({ ll: lowerLeft , ur: upperRight })\n *\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @see Query#within #query_Query-within\n * @param {String} path\n * @param {Object} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.box = function (path, val) {\n  if (arguments.length === 1) {\n    val = path;\n    path = this._currPath;\n  }\n  var conds = this._conditions[path] || (this._conditions[path] = {});\n  conds['$within'] = { '$box': [val.ll, val.ur]  };\n  return this;\n};\n\n/**\n * Specifies a $center condition\n *\n * ####Example\n *\n *     var area = { center: [50, 50], radius: 10 }\n *     query.where('loc').within.center(area)\n *\n * @param {String} path\n * @param {Object} val\n * @param {Object} [opts] options e.g. { $uniqueDocs: true }\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\nQuery.prototype.center = function (path, val, opts) {\n  if (arguments.length === 1) {\n    val = path;\n    path = this._currPath;\n  }\n  var conds = this._conditions[path] || (this._conditions[path] = {});\n  conds['$within'] = { '$center': [val.center, val.radius]  };\n\n  // copy any options\n  if (opts && 'Object' == opts.constructor.name) {\n    utils.options(opts, conds.$within);\n  }\n\n  return this;\n};\n\n/**\n * Specifies a $centerSphere condition\n *\n * ####Example\n *\n *     var area = { center: [50, 50], radius: 10 }\n *     query.where('loc').within.centerSphere(area)\n *\n * @param {String} path\n * @param {Object} val\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\nQuery.prototype.centerSphere = function (path, val) {\n  if (arguments.length === 1) {\n    val = path;\n    path = this._currPath;\n  }\n  var conds = this._conditions[path] || (this._conditions[path] = {});\n  conds['$within'] = { '$centerSphere': [val.center, val.radius]  };\n  return this;\n};\n\n/**\n * Specifies a $polygon condition\n *\n * ####Example\n *\n *     var polyA = [ [ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ] ]\n *     query.where('loc').within.polygon(polyA)\n *\n *     // or\n *     var polyB = { a : { x : 10, y : 20 }, b : { x : 15, y : 25 }, c : { x : 20, y : 20 } }\n *     query.where('loc').within.polygon(polyB)\n *\n * @param {String} path\n * @param {Array|Object} val\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\nQuery.prototype.polygon = function (path, val) {\n  if (arguments.length === 1) {\n    val = path;\n    path = this._currPath;\n  }\n  var conds = this._conditions[path] || (this._conditions[path] = {});\n  conds['$within'] = { '$polygon': val };\n  return this;\n};\n\n/**\n * Specifies which document fields to include or exclude\n *\n * When using string syntax, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included. Lastly, if a path is prefixed with `+`, it forces inclusion of the path, which is useful for paths excluded at the [schema level](/docs/api.html#schematype_SchemaType-select).\n *\n * ####Example\n *\n *     // include a and b, exclude c\n *     query.select('a b -c');\n *\n *     // or you may use object notation, useful when\n *     // you have keys already prefixed with a \"-\"\n *     query.select({a: 1, b: 1, c: 0});\n *\n *     // force inclusion of field excluded at schema level\n *     query.select('+path')\n *\n * ####NOTE:\n *\n * _v2 had slightly different syntax such as allowing arrays of field names. This support was removed in v3._\n *\n * @param {Object|String} arg\n * @return {Query} this\n * @see SchemaType\n * @api public\n */\n\nQuery.prototype.select = function select (arg) {\n  if (!arg) return this;\n\n  var fields = this._fields || (this._fields = {});\n\n  if ('Object' === arg.constructor.name) {\n    Object.keys(arg).forEach(function (field) {\n      fields[field] = arg[field];\n    });\n  } else if (1 === arguments.length && 'string' == typeof arg) {\n    arg.split(/\\s+/).forEach(function (field) {\n      if (!field) return;\n      var include = '-' == field[0] ? 0 : 1;\n      if (include === 0) field = field.substring(1);\n      fields[field] = include;\n    });\n  } else {\n    throw new TypeError('Invalid select() argument. Must be a string or object.');\n  }\n\n  return this;\n};\n\n/**\n * Specifies a $slice condition\n *\n * ####Example\n *\n *     query.slice('comments', 5)\n *     query.slice('comments', -5)\n *     query.slice('comments', [10, 5])\n *     query.where('comments').slice(5)\n *     query.where('comments').slice([-10, 5])\n *\n * @param {String} path\n * @param {Number} val number of elements to slice\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Retrieving+a+Subset+of+Fields#RetrievingaSubsetofFields-RetrievingaSubrangeofArrayElements\n * @api public\n */\n\nQuery.prototype.slice = function (path, val) {\n  if (arguments.length === 1) {\n      val = path;\n      path = this._currPath\n  } else if (arguments.length === 2) {\n    if ('number' === typeof path) {\n      val = [path, val];\n      path = this._currPath;\n    }\n  } else if (arguments.length === 3) {\n    val = utils.args(arguments, 1);\n  }\n  var myFields = this._fields || (this._fields = {});\n  myFields[path] = { '$slice': val };\n  return this;\n};\n\n/**\n * Sets the sort order\n *\n * If an object is passed, values allowed are 'asc', 'desc', 'ascending', 'descending', 1, and -1.\n *\n * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n *\n * ####Example\n *\n *     // these are equivalent\n *     query.sort({ field: 'asc', test: -1 });\n *     query.sort('field -test');\n *\n * @param {Object|String} arg\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.sort = function (arg) {\n  if (!arg) return this;\n\n  var sort = this.options.sort || (this.options.sort = []);\n\n  if ('Object' === arg.constructor.name) {\n    Object.keys(arg).forEach(function (field) {\n      push(sort, field, arg[field]);\n    });\n  } else if (1 === arguments.length && 'string' == typeof arg) {\n    arg.split(/\\s+/).forEach(function (field) {\n      if (!field) return;\n      var ascend = '-' == field[0] ? -1 : 1;\n      if (ascend === -1) field = field.substring(1);\n      push(sort, field, ascend);\n    });\n  } else {\n    throw new TypeError('Invalid sort() argument. Must be a string or object.');\n  }\n\n  return this;\n};\n\n/*!\n * @ignore\n */\n\nfunction push (arr, field, value) {\n  var val = String(value || 1).toLowerCase();\n  if (!/^(?:ascending|asc|descending|desc|1|-1)$/.test(val)) {\n    if (Array.isArray(value)) value = '['+value+']';\n    throw new TypeError('Invalid sort value: {' + field + ': ' + value + ' }');\n  }\n  arr.push([field, value]);\n}\n\n/**\n * Specifies the limit option.\n *\n * ####Example\n *\n *     Kitten.find().limit(20)\n *\n * @method limit\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D\n * @api public\n */\n/**\n * Specifies the skip option.\n *\n * ####Example\n *\n *     Kitten.find().skip(100).limit(20)\n *\n * @method skip\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D\n * @api public\n */\n/**\n * Specifies the maxscan option.\n *\n * ####Example\n *\n *     Kitten.find().maxscan(100)\n *\n * @method maxscan\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24maxScan\n * @api public\n */\n/**\n * Specifies the batchSize option.\n *\n * ####Example\n *\n *     Kitten.find().batchSize(100)\n *\n * @method batchSize\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D\n * @api public\n */\n/**\n * Specifies the `comment` option.\n *\n * ####Example\n *\n *     Kitten.findOne(condition).comment('login query')\n *\n * @method comment\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment\n * @api public\n */\n\n/*!\n * limit, skip, maxscan, batchSize, comment\n *\n * Sets these associated options.\n *\n *     query.comment('feed query');\n */\n\n;['limit', 'skip', 'maxscan', 'batchSize', 'comment'].forEach(function (method) {\n  Query.prototype[method] = function (v) {\n    this.options[method] = v;\n    return this;\n  };\n});\n\n/**\n * Specifies this query as a `snapshot` query.\n *\n * ####Example\n *\n *     Kitten.find().snapshot()\n *\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.snapshot = function () {\n  this.options.snapshot = true;\n  return this;\n};\n\n/**\n * Sets query hints.\n *\n * ####Example\n *\n *     Model.find().hint({ indexA: 1, indexB: -1})\n *\n * @param {Object} val a hint object\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint\n * @api public\n */\n\nQuery.prototype.hint = function (val) {\n  if (!val) return this;\n\n  var hint = this.options.hint || (this.options.hint = {});\n\n  if ('Object' === val.constructor.name) {\n    // must keep object keys in order so don't use Object.keys()\n    for (var k in val) {\n      hint[k] = val[k];\n    }\n  } else {\n    throw new TypeError('Invalid hint. ' + val);\n  }\n\n  return this;\n};\n\n/**\n * Sets the slaveOk option.\n *\n * ####Example:\n *\n *     new Query().slaveOk() // true\n *     new Query().slaveOk(true)\n *     new Query().slaveOk(false)\n *\n * @param {Boolean} v defaults to true\n * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.slaveOk = function (v) {\n  this.options.slaveOk = arguments.length ? !!v : true;\n  return this;\n}\n\n/**\n * Sets the readPreference option for the query.\n *\n * ####Example:\n *\n *     new Query().read('primary')\n *     new Query().read('p')  // same as primary\n *\n *     new Query().read('primaryPreferred')\n *     new Query().read('pp') // same as primaryPreferred\n *\n *     new Query().read('secondary')\n *     new Query().read('s')  // same as secondary\n *\n *     new Query().read('secondaryPreferred')\n *     new Query().read('sp') // same as secondaryPreferred\n *\n *     new Query().read('nearest')\n *     new Query().read('n')  // same as nearest\n *\n *     // with tags\n *     new Query().read('s', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }])\n *\n * ####Preferences:\n *\n *     primary - (default) Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.\n *     secondary            Read from secondary if available, otherwise error.\n *     primaryPreferred     Read from primary if available, otherwise a secondary.\n *     secondaryPreferred   Read from a secondary if available, otherwise read from the primary.\n *     nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.\n *\n * Aliases\n *\n *     p   primary\n *     pp  primaryPreferred\n *     s   secondary\n *     sp  secondaryPreferred\n *     n   nearest\n *\n * Read more about how to use read preferrences [here](http://docs.mongodb.org/manual/applications/replication/#read-preference) and [here](http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences).\n *\n * @param {String} pref one of the listed preference options or their aliases\n * @param {Array} [tags] optional tags for this query\n * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.read = function (pref, tags) {\n  this.options.readPreference = utils.readPref(pref, tags);\n  return this;\n}\n\n/**\n * Sets the lean option.\n *\n * Documents returned from queries with the `lean` option enabled are plain javascript objects, not [MongooseDocuments](#document-js). They have no `save` method, getters/setters or any other Mongoose magic applied.\n *\n * This is a [great](https://groups.google.com/forum/#!topic/mongoose-orm/u2_DzDydcnA/discussion) option in high-performance read-only scenarios, especially when combined with the [stream](#query_Query-stream) option.\n *\n * ####Example:\n *\n *     new Query().lean() // true\n *     new Query().lean(true)\n *     new Query().lean(false)\n *\n *     Model.find().lean().exec();\n *\n *     var leanStream = Model.find().lean().stream();\n *\n * @param {Boolean} v defaults to true\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.lean = function (v) {\n  this.options.lean = arguments.length ? !!v : true;\n  return this;\n}\n\n/**\n * Sets tailable option.\n *\n * ####Example\n *\n *     Kitten.find().tailable() <== true\n *     Kitten.find().tailable(true)\n *     Kitten.find().tailable(false)\n *\n * @param {Boolean} v defaults to true\n * @see mongodb http://www.mongodb.org/display/DOCS/Tailable+Cursors\n * @api public\n */\n\nQuery.prototype.tailable = function (v) {\n  this.options.tailable = arguments.length ? !!v : true;\n  return this;\n};\n\n/**\n * Executes the query as a find() operation.\n *\n * @param {Function} callback\n * @return {Query} this\n * @api private\n */\n\nQuery.prototype.execFind = function (callback) {\n  var model = this.model\n    , promise = new Promise(callback);\n\n  try {\n    this.cast(model);\n  } catch (err) {\n    promise.error(err);\n    return this;\n  }\n\n  // apply default schematype path selections\n  this._applyPaths();\n\n  var self = this\n    , castQuery = this._conditions\n    , options = this._optionsForExec(model)\n    , fields = utils.clone(this._fields)\n\n  options.fields = this._castFields(fields);\n  if (options.fields instanceof Error) {\n    promise.error(options.fields);\n    return this;\n  }\n\n  model.collection.find(castQuery, options, function (err, cursor) {\n    if (err) return promise.error(err);\n    cursor.toArray(tick(cb));\n  });\n\n  function cb (err, docs) {\n    if (err) return promise.error(err);\n\n    if (true === options.lean)\n      return promise.complete(docs);\n\n    var arr = []\n      , count = docs.length;\n\n    if (!count) return promise.complete([]);\n\n    for (var i = 0, l = docs.length; i < l; i++) {\n      arr[i] = new model(undefined, fields, true);\n      arr[i].init(docs[i], self, function (err) {\n        if (err) return promise.error(err);\n        --count || promise.complete(arr);\n      });\n    }\n  }\n\n  return this;\n};\n\n/**\n * Executes the query as a findOne() operation.\n *\n * ####Example\n *\n *     Kitten.where('color', 'white').findOne(function (err, kitten) {\n *       if (err) return handleError(err);\n *\n *       // kitten may be null if no document matched\n *       if (kitten) {\n *         ...\n *       }\n *     })\n *\n * @param {Function} callback\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.findOne = function (callback) {\n  this.op = 'findOne';\n\n  if (!callback) return this;\n\n  var model = this.model;\n  var promise = new Promise(callback);\n\n  try {\n    this.cast(model);\n  } catch (err) {\n    promise.error(err);\n    return this;\n  }\n\n  // apply default schematype path selections\n  this._applyPaths();\n\n  var self = this\n    , castQuery = this._conditions\n    , options = this._optionsForExec(model)\n    , fields = utils.clone(this._fields)\n\n  options.fields = this._castFields(fields);\n  if (options.fields instanceof Error) {\n    promise.error(options.fields);\n    return this;\n  }\n\n  model.collection.findOne(castQuery, options, tick(function (err, doc) {\n    if (err) return promise.error(err);\n    if (!doc) return promise.complete(null);\n\n    if (true === options.lean) return promise.complete(doc);\n\n    var casted = new model(undefined, fields, true);\n    casted.init(doc, self, function (err) {\n      if (err) return promise.error(err);\n      promise.complete(casted);\n    });\n  }));\n\n  return this;\n};\n\n/**\n * Exectues the query as a count() operation.\n *\n * ####Example\n *\n *     Kitten.where('color', 'black').count(function (err, count) {\n *       if (err) return handleError(err);\n *       console.log('there are %d black kittens', count);\n *     })\n *\n * @param {Function} callback\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Count\n * @api public\n */\n\nQuery.prototype.count = function (callback) {\n  this.op = 'count';\n  var model = this.model;\n\n  try {\n    this.cast(model);\n  } catch (err) {\n    return callback(err);\n  }\n\n  var castQuery = this._conditions;\n  model.collection.count(castQuery, tick(callback));\n\n  return this;\n};\n\n/**\n * Executes this query as a distict() operation.\n *\n * @param {String} field\n * @param {Function} callback\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Distinct\n * @api public\n */\n\nQuery.prototype.distinct = function (field, callback) {\n  this.op = 'distinct';\n  var model = this.model;\n\n  try {\n    this.cast(model);\n  } catch (err) {\n    return callback(err);\n  }\n\n  var castQuery = this._conditions;\n  model.collection.distinct(field, castQuery, tick(callback));\n\n  return this;\n};\n\n/*!\n * These operators require casting docs\n * to real Documents for Update operations.\n */\n\nvar castOps = {\n    $push: 1\n  , $pushAll: 1\n  , $addToSet: 1\n  , $set: 1\n};\n\n/*!\n * These operators should be cast to numbers instead\n * of their path schema type.\n */\n\nvar numberOps = {\n    $pop: 1\n  , $unset: 1\n  , $inc: 1\n}\n\n/**\n * Executes this query as an update() operation.\n *\n * _All paths passed that are not $atomic operations will become $set ops so we retain backwards compatibility._\n *\n * ####Example\n *\n *     Model.update({..}, { title: 'remove words' }, ...)\n *\n * becomes\n *\n *     Model.update({..}, { $set: { title: 'remove words' }}, ...)\n *\n * ####Note\n *\n * Passing an empty object `{}` as the doc will result in a no-op. The update operation will be ignored and the callback executed without sending the command to MongoDB so as to prevent accidently overwritting the collection.\n *\n * @param {Object} doc the update conditions\n * @param {Function} callback\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.update = function update (doc, callback) {\n  this.op = 'update';\n  this._updateArg = doc;\n\n  var model = this.model\n    , options = this._optionsForExec(model)\n    , fn = 'function' == typeof callback\n    , castedQuery\n    , castedDoc\n\n  castedQuery = castQuery(this);\n  if (castedQuery instanceof Error) {\n    if (fn) {\n      process.nextTick(callback.bind(null, castedQuery));\n      return this;\n    }\n    throw castedQuery;\n  }\n\n  castedDoc = castDoc(this);\n  if (!castedDoc) {\n    fn && process.nextTick(callback.bind(null, null, 0));\n    return this;\n  }\n\n  if (castedDoc instanceof Error) {\n    if (fn) {\n      process.nextTick(callback.bind(null, castedDoc));\n      return this;\n    }\n    throw castedDoc;\n  }\n\n  if (!fn) {\n    options.safe = { w: 0 };\n  }\n\n  model.collection.update(castedQuery, castedDoc, options, tick(callback));\n  return this;\n};\n\n/**\n * Casts obj for an update command.\n *\n * @param {Object} obj\n * @return {Object} obj after casting its values\n * @api private\n */\n\nQuery.prototype._castUpdate = function _castUpdate (obj) {\n  var ops = Object.keys(obj)\n    , i = ops.length\n    , ret = {}\n    , hasKeys\n    , val\n\n  while (i--) {\n    var op = ops[i];\n    if ('$' !== op[0]) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (obj.$set) {\n          ret.$set = obj.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = obj[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if ('$set' === op) {\n      if (!ret.$set) {\n        ret[op] = obj[op];\n      }\n    } else {\n      ret[op] = obj[op];\n    }\n  }\n\n  // cast each value\n  i = ops.length;\n\n  while (i--) {\n    op = ops[i];\n    val = ret[op];\n    if ('Object' === val.constructor.name) {\n      hasKeys |= this._walkUpdatePath(val, op);\n    } else {\n      var msg = 'Invalid atomic update value for ' + op + '. '\n              + 'Expected an object, received ' + typeof val;\n      throw new Error(msg);\n    }\n  }\n\n  return hasKeys && ret;\n}\n\n/**\n * Walk each path of obj and cast its values\n * according to its schema.\n *\n * @param {Object} obj - part of a query\n * @param {String} op - the atomic operator ($pull, $set, etc)\n * @param {String} pref - path prefix (internal only)\n * @return {Bool} true if this path has keys to update\n * @api private\n */\n\nQuery.prototype._walkUpdatePath = function _walkUpdatePath (obj, op, pref) {\n  var strict = this.model.schema.options.strict\n    , prefix = pref ? pref + '.' : ''\n    , keys = Object.keys(obj)\n    , i = keys.length\n    , hasKeys = false\n    , schema\n    , key\n    , val\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (val && 'Object' === val.constructor.name) {\n      // watch for embedded doc schemas\n      schema = this._getSchema(prefix + key);\n      if (schema && schema.caster && op in castOps) {\n        // embedded doc schema\n\n        if (strict && !schema) {\n          // path is not in our strict schema\n          if ('throw' == strict) {\n            throw new Error('Field `' + key + '` is not in schema.');\n          } else {\n            // ignore paths not specified in schema\n            delete obj[key];\n          }\n        } else {\n          hasKeys = true;\n          if ('$each' in val) {\n            obj[key] = {\n                $each: this._castUpdateVal(schema, val.$each, op)\n            }\n          } else {\n            obj[key] = this._castUpdateVal(schema, val, op);\n          }\n        }\n      } else {\n        hasKeys |= this._walkUpdatePath(val, op, prefix + key);\n      }\n    } else {\n      schema = '$each' === key\n        ? this._getSchema(pref)\n        : this._getSchema(prefix + key);\n\n      var skip = strict &&\n                 !schema &&\n                 !/real|nested/.test(this.model.schema.pathType(prefix + key));\n\n      if (skip) {\n        if ('throw' == strict) {\n          throw new Error('Field `' + prefix + key + '` is not in schema.');\n        } else {\n          delete obj[key];\n        }\n      } else {\n        hasKeys = true;\n        obj[key] = this._castUpdateVal(schema, val, op, key);\n      }\n    }\n  }\n  return hasKeys;\n}\n\n/**\n * Casts `val` according to `schema` and atomic `op`.\n *\n * @param {Schema} schema\n * @param {Object} val\n * @param {String} op - the atomic operator ($pull, $set, etc)\n * @param {String} [$conditional]\n * @api private\n */\n\nQuery.prototype._castUpdateVal = function _castUpdateVal (schema, val, op, $conditional) {\n  if (!schema) {\n    // non-existing schema path\n    return op in numberOps\n      ? Number(val)\n      : val\n  }\n\n  if (schema.caster && op in castOps &&\n    ('Object' === val.constructor.name || Array.isArray(val))) {\n    // Cast values for ops that add data to MongoDB.\n    // Ensures embedded documents get ObjectIds etc.\n    var tmp = schema.cast(val);\n\n    if (Array.isArray(val)) {\n      val = tmp;\n    } else {\n      val = tmp[0];\n    }\n  }\n\n  if (op in numberOps) return Number(val);\n  if (/^\\$/.test($conditional)) return schema.castForQuery($conditional, val);\n  return schema.castForQuery(val)\n}\n\n/**\n * Finds the schema for `path`. This is different than\n * calling `schema.path` as it also resolves paths with\n * positional selectors (something.$.another.$.path).\n *\n * @param {String} path\n * @api private\n */\n\nQuery.prototype._getSchema = function _getSchema (path) {\n  var schema = this.model.schema\n    , pathschema = schema.path(path);\n\n  if (pathschema)\n    return pathschema;\n\n  // look for arrays\n  return (function search (parts, schema) {\n    var p = parts.length + 1\n      , foundschema\n      , trypath\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        if (foundschema.caster) {\n\n          // array of Mixed?\n          if (foundschema.caster instanceof Types.Mixed) {\n            return foundschema.caster;\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          if (p !== parts.length) {\n            if ('$' === parts[p]) {\n              // comments.$.comments.$.title\n              return search(parts.slice(p+1), foundschema.schema);\n            } else {\n              // this is the last path of the selector\n              return search(parts.slice(p), foundschema.schema);\n            }\n          }\n        }\n        return foundschema;\n      }\n    }\n  })(path.split('.'), schema)\n}\n\n/**\n * Casts selected field arguments for field selection with mongo 2.2\n *\n *     query.select({ ids: { $elemMatch: { $in: [hexString] }})\n *\n * @param {Object} fields\n * @see https://github.com/LearnBoost/mongoose/issues/1091\n * @see http://docs.mongodb.org/manual/reference/projection/elemMatch/\n * @api private\n */\n\nQuery.prototype._castFields = function _castFields (fields) {\n  var selected\n    , elemMatchKeys\n    , keys\n    , key\n    , out\n    , i\n\n  if (fields) {\n    keys = Object.keys(fields);\n    elemMatchKeys = [];\n    i = keys.length;\n\n    // collect $elemMatch args\n    while (i--) {\n      key = keys[i];\n      if (fields[key].$elemMatch) {\n        selected || (selected = {});\n        selected[key] = fields[key];\n        elemMatchKeys.push(key);\n      }\n    }\n  }\n\n  if (selected) {\n    // they passed $elemMatch, cast em\n    try {\n      out = this.cast(this.model, selected);\n    } catch (err) {\n      return err;\n    }\n\n    // apply the casted field args\n    i = elemMatchKeys.length;\n    while (i--) {\n      key = elemMatchKeys[i];\n      fields[key] = out[key];\n    }\n  }\n\n  return fields;\n}\n\n/**\n * Executes this query as a remove() operation.\n *\n * ####Example\n *\n *     Cassette.where('artist').equals('Anne Murray').remove(callback)\n *\n * @param {Function} callback\n * @api public\n */\n\nQuery.prototype.remove = function (callback) {\n  this.op = 'remove';\n\n  var model = this.model\n    , options = this._optionsForExec(model)\n    , cb = 'function' == typeof callback\n\n  try {\n    this.cast(model);\n  } catch (err) {\n    if (cb) return callback(err);\n    throw err;\n  }\n\n  if (!cb) {\n    options.safe = { w: 0 };\n  }\n\n  var castQuery = this._conditions;\n  model.collection.remove(castQuery, options, tick(callback));\n  return this;\n};\n\n/**\n * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) update command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes immediately if `callback` is passed else a Query object is returned.\n *\n * ####Available options\n *\n * - `new`: bool - true to return the modified document rather than the original. defaults to true\n * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n *\n * ####Examples\n *\n *     query.findOneAndUpdate(conditions, update, options, callback) // executes\n *     query.findOneAndUpdate(conditions, update, options)  // returns Query\n *     query.findOneAndUpdate(conditions, update, callback) // executes\n *     query.findOneAndUpdate(conditions, update)           // returns Query\n *     query.findOneAndUpdate(callback)                     // executes\n *     query.findOneAndUpdate()                             // returns Query\n *\n * @param {Object} [query]\n * @param {Object} [doc]\n * @param {Object} [options]\n * @param {Function} [callback]\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.findOneAndUpdate = function (query, doc, options, callback) {\n  this.op = 'findOneAndUpdate';\n\n  switch (arguments.length) {\n    case 3:\n      if ('function' == typeof options)\n        callback = options, options = {};\n      break;\n    case 2:\n      if ('function' == typeof doc) {\n        callback = doc;\n        doc = query;\n        query = undefined;\n      }\n      options = undefined;\n      break;\n    case 1:\n      if ('function' == typeof query) {\n        callback = query;\n        query = options = doc = undefined;\n      } else {\n        doc = query;\n        query = options = undefined;\n      }\n  }\n\n  // apply query\n  if (query) {\n    if ('Object' === query.constructor.name) {\n      merge(this._conditions, query);\n    } else if (query instanceof Query) {\n      merge(this._conditions, query._conditions);\n    } else if (query instanceof Document) {\n      merge(this._conditions, query.toObject());\n    }\n  }\n\n  // apply doc\n  if (doc) {\n    merge(this._updateArg, doc);\n  }\n\n  // apply options\n  options && this.setOptions(options);\n\n  if (!callback) return this;\n\n  return this._findAndModify('update', callback);\n}\n\n/**\n * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) remove command.\n *\n * Finds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if `callback` is passed else a Query object is returned.\n *\n * ####Available options\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n *\n * ####Examples\n *\n *     A.where().findOneAndRemove(conditions, options, callback) // executes\n *     A.where().findOneAndRemove(conditions, options)  // return Query\n *     A.where().findOneAndRemove(conditions, callback) // executes\n *     A.where().findOneAndRemove(conditions) // returns Query\n *     A.where().findOneAndRemove(callback)   // executes\n *     A.where().findOneAndRemove()           // returns Query\n *\n * @param {Object} [conditions]\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @api public\n */\n\nQuery.prototype.findOneAndRemove = function (conditions, options, callback) {\n  this.op = 'findOneAndRemove';\n\n  if ('function' == typeof options) {\n    callback = options;\n    options = undefined;\n  } else if ('function' == typeof conditions) {\n    callback = conditions;\n    conditions = undefined;\n  }\n\n  // apply conditions\n  if (conditions) {\n    if ('Object' === conditions.constructor.name) {\n      merge(this._conditions, conditions);\n    } else if (conditions instanceof Query) {\n      merge(this._conditions, conditions._conditions);\n    } else if (conditions instanceof Document) {\n      merge(this._conditions, conditions.toObject());\n    }\n  }\n\n  // apply options\n  options && this.setOptions(options);\n\n  if (!callback) return this;\n\n  return this._findAndModify('remove', callback);\n}\n\n/**\n * _findAndModify\n *\n * @param {String} type - either \"remove\" or \"update\"\n * @param {Function} callback\n * @api private\n */\n\nQuery.prototype._findAndModify = function (type, callback) {\n  var model = this.model\n    , promise = new Promise(callback)\n    , self = this\n    , castedQuery\n    , castedDoc\n    , fields\n    , sort\n    , opts\n\n  castedQuery = castQuery(this);\n  if (castedQuery instanceof Error) {\n    process.nextTick(promise.error.bind(promise, castedQuery));\n    return promise;\n  }\n\n  opts = this._optionsForExec(model);\n\n  if ('remove' == type) {\n    opts.remove = true;\n  } else {\n    if (!('new' in opts)) opts.new = true;\n    if (!('upsert' in opts)) opts.upsert = false;\n\n    castedDoc = castDoc(this);\n    if (!castedDoc) {\n      if (opts.upsert) {\n        // still need to do the upsert to empty doc\n        castedDoc = { $set: {} };\n      } else {\n        return this.findOne(callback);\n      }\n    } else if (castedDoc instanceof Error) {\n      process.nextTick(promise.error.bind(promise, castedDoc));\n      return promise;\n    }\n  }\n\n  this._applyPaths();\n\n  if (this._fields) {\n    fields = utils.clone(this._fields)\n    opts.fields = this._castFields(fields);\n    if (opts.fields instanceof Error) {\n      process.nextTick(promise.error.bind(promise, opts.fields));\n      return promise;\n    }\n  }\n\n  // the driver needs a default\n  sort = opts.sort || [];\n\n  model\n  .collection\n  .findAndModify(castedQuery, sort, castedDoc, opts, tick(function (err, doc) {\n    if (err) return promise.error(err);\n    if (!doc) return promise.complete(null);\n\n    if (true === opts.lean) {\n      return promise.complete(doc);\n    }\n\n    var casted = new model(undefined, fields, true);\n    casted.init(doc, self, function (err) {\n      if (err) return promise.error(err);\n      promise.complete(casted);\n    });\n  }));\n\n  return promise;\n}\n\n/**\n * Specifies paths which should be populated with other documents.\n *\n * Paths are populated after the query executes and a response is received. A separate query is then executed for each path specified for population. After a response for each query has also been returned, the results are passed to the callback.\n *\n * ####Example:\n *\n *     Kitten.findOne().populate('owner').exec(function (err, kitten) {\n *       console.log(kitten.owner.name) // Max\n *     })\n *\n * @param {String} path\n * @param {Object|String} [fields] Field selection for the population query\n * @param {Model} [model] The name of the model you wish to use for population. If not specified, the name is looked up from the Schema ref.\n * @param {Object} [conditions] Conditions for the population query\n * @param {Object} [options] Options for the population query (sort, etc)\n * @see population ./populate.html\n * @see Query#select #query_Query-select\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.populate = function (path, fields, model, conditions, options) {\n  if ('string' !== typeof model) {\n    options = conditions;\n    conditions = model;\n    model = undefined;\n  }\n  // The order of fields/conditions args is opposite Model.find but\n  // necessary to keep backward compatibility (fields could be\n  // an array, string, or object literal).\n  this.options.populate[path] =\n    new PopulateOptions(fields, conditions, options, model);\n\n  return this;\n};\n\n/*!\n * Populate options constructor\n */\n\nfunction PopulateOptions (fields, conditions, options, model) {\n  this.conditions = conditions;\n  this.fields = fields;\n  this.options = options;\n  this.model = model;\n}\n\n// make it compatible with utils.clone\nPopulateOptions.prototype.constructor = Object;\n\n/**\n * Returns a Node.js 0.8 style [read stream](http://nodejs.org/docs/v0.8.21/api/stream.html#stream_readable_stream) interface.\n *\n * ####Example\n *\n *     // follows the nodejs 0.8 stream api\n *     Thing.find({ name: /^hello/ }).stream().pipe(res)\n *\n *     // manual streaming\n *     var stream = Thing.find({ name: /^hello/ }).stream();\n *\n *     stream.on('data', function (doc) {\n *       // do something with the mongoose document\n *     }).on('error', function (err) {\n *       // handle the error\n *     }).on('close', function () {\n *       // the stream is closed\n *     });\n *\n * ####Valid options\n *\n *   - transform: optional function which accepts a mongoose document. The return value of the function will be emitted.\n *\n * ####Example\n *\n *     // JSON.stringify all documents before emitting\n *     var stream = Thing.find().stream({ transform: JSON.stringify });\n *     stream.pipe(writeStream);\n *\n * @return {QueryStream}\n * @param {Object} [options]\n * @see QueryStream\n * @api public\n */\n\nQuery.prototype.stream = function stream (opts) {\n  return new QueryStream(this, opts);\n}\n\n// helpers\n\n/*!\n * castDoc\n * @api private\n */\n\nfunction castDoc (query) {\n  try {\n    return query._castUpdate(query._updateArg);\n  } catch (err) {\n    return err;\n  }\n}\n\n/*!\n * castQuery\n * @api private\n */\n\nfunction castQuery (query) {\n  try {\n    return query.cast(query.model);\n  } catch (err) {\n    return err;\n  }\n}\n\n/*!\n * Exports.\n */\n\nmodule.exports = Query;\nmodule.exports.QueryStream = QueryStream;\n"]],"start1":0,"start2":0,"length1":0,"length2":60100}]],"length":60100}
