{"ts":1363486816561,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*!\n * Module dependencies.\n */\n\nvar Document = require('./document')\n  , MongooseArray = require('./types/array')\n  , MongooseBuffer = require('./types/buffer')\n  , MongooseError = require('./error')\n  , VersionError = require('./errors/version')\n  , Query = require('./query')\n  , Schema = require('./schema')\n  , utils = require('./utils')\n  , isMongooseObject = utils.isMongooseObject\n  , EventEmitter = require('events').EventEmitter\n  , merge = utils.merge\n  , Promise = require('./promise')\n  , tick = utils.tick\n\nvar VERSION_WHERE = 1\n  , VERSION_INC = 2\n  , VERSION_ALL = VERSION_WHERE | VERSION_INC;\n\n/**\n * Model constructor\n *\n * @param {Object} doc values to with which to create the document\n * @inherits Document\n * @event `error`: If listening to this Model event, it is emitted when a document was saved without passing a callback and an `error` occurred. If not listening, the event bubbles to the connection used to create this Model.\n * @event `index`: Emitted after `Model#ensureIndexes` completes. If an error occurred it is passed with the event.\n * @api public\n */\n\nfunction Model (doc, fields, skipId) {\n  Document.call(this, doc, fields, skipId);\n};\n\n/*!\n * Inherits from Document.\n *\n * All Model.prototype features are available on\n * top level (non-sub) documents.\n */\n\nModel.prototype.__proto__ = Document.prototype;\n\n/**\n * Connection the model uses.\n *\n * @api public\n * @property db\n */\n\nModel.prototype.db;\n\n/**\n * Collection the model uses.\n *\n * @api public\n * @property collection\n */\n\nModel.prototype.collection;\n\n/**\n * The name of the model\n *\n * @api public\n * @property modelName\n */\n\nModel.prototype.modelName;\n\n/**\n * Returns what paths can be populated\n *\n * @param {Query} query object\n * @return {Object|undefined} population paths\n * @api private\n */\n\nModel.prototype._getPopulationKeys = function getPopulationKeys (query) {\n  if (!(query && query.options.populate)) return;\n\n  var names = Object.keys(query.options.populate)\n    , n = names.length\n    , name\n    , paths = {}\n    , hasKeys\n    , schema\n\n  while (n--) {\n    name = names[n];\n    schema = this.schema.path(name);\n    hasKeys = true;\n\n    if (!schema) {\n      // if the path is not recognized, it's potentially embedded docs\n      // walk path atoms from right to left to find a matching path\n      var pieces = name.split('.')\n        , i = pieces.length;\n\n      while (i--) {\n        var path = pieces.slice(0, i).join('.')\n          , pathSchema = this.schema.path(path);\n\n        // loop until we find an array schema\n        if (pathSchema && pathSchema.caster) {\n          if (!paths[path]) {\n            paths[path] = { sub: {} };\n          }\n\n          paths[path].sub[pieces.slice(i).join('.')] = query.options.populate[name];\n          hasKeys || (hasKeys = true);\n          break;\n        }\n      }\n    } else {\n      paths[name] = query.options.populate[name];\n      hasKeys || (hasKeys = true);\n    }\n  }\n\n  return hasKeys && paths;\n};\n\n/**\n * Populates an object\n *\n * @param {SchemaType} schema type for the oid\n * @param {Object} oid object id or array of object ids\n * @param {Object} query object specifying query conditions, fields, and options\n * @param {Function} fn\n * @api private\n */\n\nModel.prototype._populate = function populate (schema, oid, query, fn) {\n  if (!Array.isArray(oid)) {\n    var conditions = query.conditions || {};\n    conditions._id = oid;\n\n    return this\n    .db.model(query.model || schema.options.ref)\n    .findOne(conditions, query.fields, query.options, fn);\n  }\n\n  if (!oid.length) {\n    return fn(null, oid);\n  }\n\n  var model = this.db.model(query.model || schema.caster.options.ref)\n    , conditions = query && query.conditions || {};\n\n  conditions._id || (conditions._id = { $in: oid });\n\n  model.find(conditions, query.fields, query.options, function (err, docs) {\n    if (err) return fn(err);\n\n    // user specified sort order?\n    if (query.options && query.options.sort) {\n      return fn(null, docs);\n    }\n\n    // put back in original id order (using a hash reduces complexity from n*n to 2n)\n    var docHash = {};\n    docs.forEach(function (doc) {\n      docHash[doc._id] = doc;\n    });\n\n    var arr = [];\n    oid.forEach(function (id) {\n      if (id in docHash) arr.push(docHash[id]);\n    });\n\n    fn(null, arr);\n  });\n};\n\n/**\n * Performs auto-population of relations.\n *\n * @param {Object} doc document returned by mongo\n * @param {Query} query query that originated the initialization\n * @param {Function} fn\n * @api private\n */\n\nModel.prototype.init = function init (doc, query, fn) {\n  if ('function' == typeof query) {\n    fn = query;\n    query = null;\n  }\n\n  var populate = this._getPopulationKeys(query);\n\n  if (!populate) {\n    return Document.prototype.init.call(this, doc, fn);\n  }\n\n  // population from other models is necessary\n  var self = this;\n\n  init(doc, '', function (err) {\n    if (err) return fn(err);\n    Document.prototype.init.call(self, doc, fn);\n  });\n\n  return this;\n\n  function init (obj, prefix, fn) {\n    prefix = prefix || '';\n\n    var keys = Object.keys(obj)\n      , len = keys.length;\n\n    return next();\n\n    function next () {\n      if (--len < 0) return fn();\n\n      var i = keys[len]\n        , path = prefix + i\n        , schema = self.schema.path(path)\n        , total = 0\n        , inline = false\n        , poppath\n\n      if (!schema && obj[i] && 'Object' === obj[i].constructor.name) {\n        // assume nested object\n        return init(obj[i], path + '.', next);\n      }\n\n      if (!(obj[i] && schema && populate[path])) return next();\n\n      // this query object is re-used and passed around. we clone\n      // it to prevent query condition contamination between\n      // one populate call to the next.\n      poppath = utils.clone(populate[path]);\n\n      if (poppath.sub) {\n        obj[i].forEach(function (subobj) {\n          inline = true;\n\n          var pkeys = Object.keys(poppath.sub)\n            , pi = pkeys.length\n            , key\n\n          while (pi--) {\n            key = pkeys[pi];\n\n            if (subobj[key]) (function (key) {\n              total++;\n              self._populate(schema.schema.path(key), subobj[key], poppath.sub[key], done);\n              function done (err, doc) {\n                if (err) return error(err);\n                subobj[key] = doc;\n                if (--total < 1 && !inline) {\n                  next();\n                }\n              }\n            })(key);\n          }\n        });\n\n        inline = false;\n\n        if (0 === total) return next();\n\n      } else {\n        self._populate(schema, obj[i], poppath, function (err, doc) {\n          if (err) return error(err);\n          obj[i] = doc;\n          next();\n        });\n      }\n    };\n  };\n\n  function error (err) {\n    if (error.err) return;\n    fn(error.err = err);\n  }\n};\n\n/*!\n * Handles doc.save() callbacks\n */\n\nfunction handleSave (promise, self) {\n  return tick(function handleSave (err, result) {\n    if (err) {\n      // If the initial insert fails provide a second chance.\n      // (If we did this all the time we would break updates)\n      if (self._inserting) {\n        self.isNew = true;\n        self.emit('isNew', true);\n      }\n      promise.error(err);\n      promise = self = null;\n      return;\n    }\n\n    self._storeShard();\n\n    var numAffected;\n    if (result) {\n      // when inserting, the array of created docs is returned\n      numAffected = result.length\n        ? result.length\n        : result;\n    } else {\n      numAffected = 0;\n    }\n\n    // was this an update that required a version bump?\n    if (self.__version && !self._inserting) {\n      var doIncrement = VERSION_INC === (VERSION_INC & self.__version);\n      self.__version = undefined;\n\n      // increment version if was successful\n      if (numAffected > 0) {\n        if (doIncrement) {\n          var key = self.schema.options.versionKey;\n          var version = self.getValue(key) | 0;\n          self.setValue(key, version + 1);\n        }\n      } else {\n        // the update failed. pass an error back\n        promise.error(new VersionError);\n        promise = self = null;\n        return;\n      }\n    }\n\n    self.emit('save', self, numAffected);\n    promise.complete(self, numAffected);\n    promise = self = null;\n  });\n}\n\n/**\n * Saves this document.\n *\n * ####Example:\n *\n *     product.sold = Date.now();\n *     product.save(function (err, product) {\n *       if (err) ..\n *     })\n *\n * The `fn` callback is optional. If no `fn` is passed and validation fails, the validation error will be emitted on the connection used to create this model.\n *\n *     var db = mongoose.createConnection(..);\n *     var schema = new Schema(..);\n *     var Product = db.model('Product', schema);\n *\n *     db.on('error', handleError);\n *\n * However, if you desire more local error handling you can add an `error` listener to the model and handle errors there instead.\n *\n *     Product.on('error', handleError);\n *\n * @param {Function} [fn] optional callback\n * @api public\n * @see middleware http://mongoosejs.com/docs/middleware.html\n */\n\nModel.prototype.save = function save (fn) {\n  var promise = new Promise(fn)\n    , complete = handleSave(promise, this)\n    , options = {}\n\n  if (this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n\n  if (this.isNew) {\n    // send entire doc\n    var obj = this.toObject({ depopulate: 1 });\n    this._version(true, obj);\n    this.collection.insert(obj, options, complete);\n    this._reset();\n    this.isNew = false;\n    this.emit('isNew', false);\n    // Make it possible to retry the insert\n    this._inserting = true;\n\n  } else {\n    // Make sure we don't treat it as a new object on error,\n    // since it already exists\n    this._inserting = false;\n\n    var delta = this._delta();\n    if (delta) {\n      var where = this._where(delta[0]);\n      this.collection.update(where, delta[1], options, complete);\n    } else {\n      process.nextTick(function () {\n        complete(null);\n      })\n    }\n\n    this._reset();\n    this.emit('isNew', false);\n  }\n};\n\n/*!\n * Apply the operation to the delta (update) clause as\n * well as track versioning for our where clause.\n *\n * @param {Document} self\n * @param {Object} where\n * @param {Object} delta\n * @param {Object} data\n * @param {Mixed} val\n * @param {String} [operation]\n */\n\nfunction operand (self, where, delta, data, val, op) {\n  // delta\n  op || (op = '$set');\n  if (!delta[op]) delta[op] = {};\n  delta[op][data.path] = val;\n\n  // disabled versioning?\n  if (false === self.schema.options.versionKey) return;\n\n  // already marked for versioning?\n  if (VERSION_ALL === (VERSION_ALL & self.__version)) return;\n\n  switch (op) {\n    case '$set':\n    case '$unset':\n    case '$pop':\n    case '$pull':\n    case '$pullAll':\n    case '$push':\n    case '$pushAll':\n    case '$addToSet':\n      break;\n    default:\n      // nothing to do\n      return;\n  }\n\n  // ensure updates sent with positional notation are\n  // editing the correct array element.\n  // only increment the version if an array position changes.\n  // modifying elements of an array is ok if position does not change.\n\n  if ('$push' == op || '$pushAll' == op || '$addToSet' == op) {\n    self.__version = VERSION_INC;\n  }\n  else if (/^\\$p/.test(op)) {\n    // potentially changing array positions\n    self.increment();\n  }\n  else if (Array.isArray(val)) {\n    // $set an array\n    self.increment();\n  }\n  // now handling $set, $unset\n  else if (/\\.\\d+/.test(data.path)) {\n    // subpath of array\n    self.__version = VERSION_WHERE;\n  }\n}\n\n/*!\n * Compiles an update and where clause for a `val` with _atomics.\n *\n * @param {Document} self\n * @param {Object} where\n * @param {Object} delta\n * @param {Object} data\n * @param {Array} val\n */\n\nfunction handleAtomics (self, where, delta, data, val) {\n  if (delta.$set && delta.$set[data.path]) {\n    // $set has precedence over other atomics\n    return;\n  }\n\n  var atomics = val._atomics\n    , ops = Object.keys(atomics)\n    , schema = data.schema\n    , path = data.path\n    , i = ops.length\n    , val\n    , op;\n\n  if (0 === i) {\n    // $set\n\n    if (isMongooseObject(val)) {\n      val = val.toObject({ depopulate: 1 });\n    } else if (val.valueOf) {\n      val = val.valueOf();\n    }\n\n    return operand(self, where, delta, data, val);\n  }\n\n  while (i--) {\n    op = ops[i];\n    val = atomics[op];\n    if (isMongooseObject(val)) {\n      val = val.toObject({ depopulate: 1 })\n    } else if (Array.isArray(val)) {\n      val = val.map(function (mem) {\n        return isMongooseObject(mem)\n          ? mem.toObject({ depopulate: 1 })\n          : mem;\n      })\n    } else if (val.valueOf) {\n      val = val.valueOf()\n    }\n\n    if ('$addToSet' === op)\n      val = { $each: val };\n\n    operand(self, where, delta, data, val, op);\n  }\n}\n\n/**\n * Produces a special query document of the modified properties used in updates.\n *\n * @api private\n */\n\nModel.prototype._delta = function _delta () {\n  var dirty = this._dirty();\n  if (!dirty.length) return;\n\n  var self = this\n    , where = {}\n    , delta = {}\n    , len = dirty.length\n    , d = 0\n    , val\n    , obj\n\n  for (; d < len; ++d) {\n    var data = dirty[d]\n    var value = data.value\n    var schema = data.schema\n\n    if (undefined === value) {\n      operand(self, where, delta, data, 1, '$unset');\n\n    } else if (null === value) {\n      operand(self, where, delta, data, null);\n\n    } else if (value._path && value._atomics) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(self, where, delta, data, value);\n\n    } else if (value._path && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(self, where, delta, data, value);\n\n    } else {\n      value = utils.clone(value);\n      operand(self, where, delta, data, value);\n    }\n  }\n\n  if (this.__version) {\n    this._version(where, delta);\n  }\n\n  return [where, delta];\n}\n\n/**\n * Appends versioning to the where and update clauses.\n *\n * @api private\n */\n\nModel.prototype._version = function _version (where, delta) {\n  var key = this.schema.options.versionKey;\n\n  if (true === where) {\n    // this is an insert\n    if (key) this.setValue(key, delta[key] = 0);\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n  // TODO fail fast option?\n  if (!this.isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don't need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.__version)) {\n    where[key] = this.getValue(key);\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.__version)) {\n    delta.$inc || (delta.$inc = {});\n    delta.$inc[key] = 1;\n  }\n}\n\n/**\n * Signal that we desire an increment of this documents version.\n *\n * @see versionKeys http://mongoosejs.com/docs/guide.html#versionKey\n * @api public\n */\n\nModel.prototype.increment = function increment () {\n  this.__version = VERSION_ALL;\n  return this;\n}\n\n/**\n * Returns a query object which applies shardkeys if they exist.\n *\n * @api private\n */\n\nModel.prototype._where = function _where (where) {\n  where || (where = {});\n\n  var paths\n    , len\n\n  if (this._shardval) {\n    paths = Object.keys(this._shardval)\n    len = paths.length\n\n    for (var i = 0; i < len; ++i) {\n      where[paths[i]] = this._shardval[paths[i]];\n    }\n  }\n\n  where._id = this._doc._id;\n  return where;\n}\n\n/**\n * Removes this document from the db.\n *\n * ####Example:\n *\n *     product.remove(function (err, product) {\n *       if (err) return handleError(err);\n *       Product.findById(product._id, function (err, product) {\n *         console.log(product) // null\n *       })\n *     })\n *\n * @param {Function} [fn] optional callback\n * @api public\n */\n\nModel.prototype.remove = function remove (fn) {\n  if (this._removing) {\n    this._removing.addBack(fn);\n    return this;\n  }\n\n  var promise = this._removing = new Promise(fn)\n    , where = this._where()\n    , self = this\n    , options = {}\n\n  if (this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n\n  this.collection.remove(where, options, tick(function (err) {\n    if (err) {\n      promise.error(err);\n      promise = self = self._removing = where = options = null;\n      return;\n    }\n    self.emit('remove', self);\n    promise.complete();\n    promise = self = where = options = null;\n  }));\n\n  return this;\n};\n\n/**\n * Register hooks override\n *\n * @api private\n */\n\nModel.prototype._registerHooks = function registerHooks () {\n  Document.prototype._registerHooks.call(this);\n};\n\n/**\n * Returns another Model instance.\n *\n * ####Example:\n *\n *     var doc = new Tank;\n *     doc.model('User').findById(id, callback);\n *\n * @param {String} name model name\n * @api public\n */\n\nModel.prototype.model = function model (name) {\n  return this.db.model(name);\n};\n\n// Model (class) features\n\n/*!\n * Give the constructor the ability to emit events.\n */\n\nfor (var i in EventEmitter.prototype)\n  Model[i] = EventEmitter.prototype[i];\n\n/**\n * Called when the model compiles.\n *\n * @api private\n */\n\nModel.init = function init () {\n  if (this.schema.options.autoIndex) {\n    this.ensureIndexes();\n  }\n\n  this.schema.emit('init', this);\n};\n\n/**\n * Sends `ensureIndex` commands to mongo for each index declared in the schema.\n *\n * ####Example:\n *\n *     Event.ensureIndexes(function (err) {\n *       if (err) return handleError(err);\n *     });\n *\n * After completion, an `index` event is emitted on this `Model` passing an error if one occurred.\n *\n * ####Example:\n *\n *     var eventSchema = new Schema({ thing: { type: 'string', unique: true }})\n *     var Event = mongoose.model('Event', eventSchema);\n *\n *     Event.on('index', function (err) {\n *       if (err) console.error(err); // error occurred during index creation\n *     })\n *\n * _NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution._\n *\n * The `ensureIndex` commands are not sent in parallel. This is to avoid the `MongoError: cannot add index with a background operation in progress` error. See [this ticket](https://github.com/LearnBoost/mongoose/issues/1365) for more information.\n *\n * @param {Function} [cb] optional callback\n * @api public\n */\n\nModel.ensureIndexes = function ensureIndexes (cb) {\n  var indexes = this.schema.indexes();\n  if (!indexes.length) {\n    return cb && process.nextTick(cb);\n  }\n\n  // Indexes are created one-by-one to support how MongoDB < 2.4 deals\n  // with background indexes.\n\n  var self = this\n    , safe = self.schema.options.safe\n\n  function done (err) {\n    self.emit('index', err);\n    cb && cb(err);\n  }\n\n  function create () {\n    var index = indexes.shift();\n    if (!index) return done();\n\n    var options = index[1];\n    options.safe = safe;\n    self.collection.ensureIndex(index[0], options, tick(function (err) {\n      if (err) return done(err);\n      create();\n    }));\n  }\n\n  create();\n}\n\n/**\n * Schema the model uses.\n *\n * @property schema\n * @receiver Model\n * @api public\n */\n\nModel.schema;\n\n/*!\n * Connection instance the model uses.\n *\n * @property db\n * @receiver Model\n * @api public\n */\n\nModel.db;\n\n/*!\n * Collection the model uses.\n *\n * @property collection\n * @receiver Model\n * @api public\n */\n\nModel.collection;\n\n/**\n * Base Mongoose instance the model uses.\n *\n * @property base\n * @receiver Model\n * @api public\n */\n\nModel.base;\n\n/**\n * Removes documents from the collection.\n *\n * ####Example:\n *\n *     Comment.remove({ title: 'baby born from alien father' }, function (err) {\n *\n *     });\n *\n * ####Note:\n *\n * To remove documents without waiting for a response from MongoDB, do not pass a `callback`, then call `exec` on the returned [Query](#query-js):\n *\n *     var query = Comment.remove({ _id: id });\n *     query.exec();\n *\n * ####Note:\n *\n * This method sends a remove command directly to MongoDB, no Mongoose documents are involved. Because no Mongoose documents are involved, _no middleware (hooks) are executed_.\n *\n * @param {Object} conditions\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.remove = function remove (conditions, callback) {\n  if ('function' === typeof conditions) {\n    callback = conditions;\n    conditions = {};\n  }\n\n  var query = new Query(conditions).bind(this, 'remove');\n\n  if ('undefined' === typeof callback)\n    return query;\n\n  this._applyNamedScope(query);\n  return query.remove(callback);\n};\n\n/**\n * Finds documents\n *\n * The `conditions` are cast to their respective SchemaTypes before the command is sent.\n *\n * ####Examples:\n *\n *     // named john and at least 18\n *     MyModel.find({ name: 'john', age: { $gte: 18 }});\n *\n *     // executes immediately, passing results to callback\n *     MyModel.find({ name: 'john', age: { $gte: 18 }}, function (err, docs) {});\n *\n *     // name LIKE john and only selecting the \"name\" and \"friends\" fields, executing immediately\n *     MyModel.find({ name: /john/i }, 'name friends', function (err, docs) { })\n *\n *     // passing options\n *     MyModel.find({ name: /john/i }, null, { skip: 10 })\n *\n *     // passing options and executing immediately\n *     MyModel.find({ name: /john/i }, null, { skip: 10 }, function (err, docs) {});\n *\n *     // executing a query explicitly\n *     var query = MyModel.find({ name: /john/i }, null, { skip: 10 })\n *     query.exec(function (err, docs) {});\n *\n *     // using the promise returned from executing a query\n *     var query = MyModel.find({ name: /john/i }, null, { skip: 10 });\n *     var promise = query.exec();\n *     promise.addBack(function (err, docs) {});\n *\n * @param {Object} conditions\n * @param {Object} [fields] optional fields to select\n * @param {Object} [options] optional\n * @param {Function} [callback]\n * @return {Query}\n * @see field selection #query_Query-select\n * @see promise #promise-js\n * @api public\n */\n\nModel.find = function find (conditions, fields, options, callback) {\n  if ('function' == typeof conditions) {\n    callback = conditions;\n    conditions = {};\n    fields = null;\n    options = null;\n  } else if ('function' == typeof fields) {\n    callback = fields;\n    fields = null;\n    options = null;\n  } else if ('function' == typeof options) {\n    callback = options;\n    options = null;\n  }\n\n  var query = new Query(conditions, options);\n  query.bind(this, 'find');\n  query.select(fields);\n\n  if ('undefined' === typeof callback)\n    return query;\n\n  this._applyNamedScope(query);\n  return query.find(callback);\n};\n\n/**\n * Merges the current named scope query into `query`.\n *\n * @param {Query} query\n * @return {Query}\n * @api private\n */\n\nModel._applyNamedScope = function _applyNamedScope (query) {\n  var cQuery = this._cumulativeQuery;\n\n  if (cQuery) {\n    merge(query._conditions, cQuery._conditions);\n    if (query._fields && cQuery._fields)\n      merge(query._fields, cQuery._fields);\n    if (query.options && cQuery.options)\n      merge(query.options, cQuery.options);\n    delete this._cumulativeQuery;\n  }\n\n  return query;\n}\n\n/**\n * Finds a single document by id.\n *\n * The `id` is cast based on the Schema before sending the command.\n *\n * ####Example:\n *\n *     // find adventure by id and execute immediately\n *     Adventure.findById(id, function (err, adventure) {});\n *\n *     // same as above\n *     Adventure.findById(id).exec(callback);\n *\n *     // select only the adventures name and length\n *     Adventure.findById(id, 'name length', function (err, adventure) {});\n *\n *     // same as above\n *     Adventure.findById(id, 'name length').exec(callback);\n *\n *     // include all properties except for `length`\n *     Adventure.findById(id, '-length').exec(function (err, adventure) {});\n *\n *     // passing options (in this case return the raw js objects, not mongoose documents by passing `lean`\n *     Adventure.findById(id, 'name', { lean: true }, function (err, doc) {});\n *\n *     // same as above\n *     Adventure.findById(id, 'name').lean().exec(function (err, doc) {});\n *\n * @param {ObjectId|HexId} id objectid, or a value that can be casted to one\n * @param {Object} [fields] optional fields to select\n * @param {Object} [options] optional\n * @param {Function} [callback]\n * @return {Query}\n * @see field selection #query_Query-select\n * @see lean queries #query_Query-lean\n * @api public\n */\n\nModel.findById = function findById (id, fields, options, callback) {\n  return this.findOne({ _id: id }, fields, options, callback);\n};\n\n/**\n * Finds one document.\n *\n * The `conditions` are cast to their respective SchemaTypes before the command is sent.\n *\n * ####Example:\n *\n *     // find one iphone adventures - iphone adventures??\n *     Adventure.findOne({ type: 'iphone' }, function (err, adventure) {});\n *\n *     // same as above\n *     Adventure.findOne({ type: 'iphone' }).exec(function (err, adventure) {});\n *\n *     // select only the adventures name\n *     Adventure.findOne({ type: 'iphone' }, 'name', function (err, adventure) {});\n *\n *     // same as above\n *     Adventure.findOne({ type: 'iphone' }, 'name').exec(function (err, adventure) {});\n *\n *     // specify options, in this case lean\n *     Adventure.findOne({ type: 'iphone' }, 'name', { lean: true }, callback);\n *\n *     // same as above\n *     Adventure.findOne({ type: 'iphone' }, 'name', { lean: true }).exec(callback);\n *\n *     // chaining findOne queries (same as above)\n *     Adventure.findOne({ type: 'iphone' }).select('name').lean().exec(callback);\n *\n * @param {Object} conditions\n * @param {Object} [fields] optional fields to select\n * @param {Object} [options] optional\n * @param {Function} [callback]\n * @return {Query}\n * @see field selection #query_Query-select\n * @see lean queries #query_Query-lean\n * @api public\n */\n\nModel.findOne = function findOne (conditions, fields, options, callback) {\n  if ('function' == typeof options) {\n    callback = options;\n    options = null;\n  } else if ('function' == typeof fields) {\n    callback = fields;\n    fields = null;\n    options = null;\n  } else if ('function' == typeof conditions) {\n    callback = conditions;\n    conditions = {};\n    fields = null;\n    options = null;\n  }\n\n  var query = new Query(conditions, options).select(fields).bind(this, 'findOne');\n\n  if ('undefined' == typeof callback)\n    return query;\n\n  this._applyNamedScope(query);\n  return query.findOne(callback);\n};\n\n/**\n * Counts number of matching documents in a database collection.\n *\n * ####Example:\n *\n *     Adventure.count({ type: 'jungle' }, function (err, count) {\n *       if (err) ..\n *       console.log('there are %d jungle adventures', count);\n *     });\n *\n * @param {Object} conditions\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.count = function count (conditions, callback) {\n  if ('function' === typeof conditions)\n    callback = conditions, conditions = {};\n\n  var query = new Query(conditions).bind(this, 'count');\n  if ('undefined' == typeof callback)\n    return query;\n\n  this._applyNamedScope(query);\n  return query.count(callback);\n};\n\n/**\n * Executes a DISTINCT command\n *\n * @param {String} field\n * @param {Object} [conditions] optional\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.distinct = function distinct (field, conditions, callback) {\n  var query = new Query(conditions).bind(this, 'distinct');\n  if ('undefined' == typeof callback) {\n    query._distinctArg = field;\n    return query;\n  }\n\n  this._applyNamedScope(query);\n  return query.distinct(field, callback);\n};\n\n/**\n * Creates a Query, applies the passed conditions, and returns the Query.\n *\n * For example, instead of writing:\n *\n *     User.find({age: {$gte: 21, $lte: 65}}, callback);\n *\n * we can instead write:\n *\n *     User.where('age').gte(21).lte(65).exec(callback);\n *\n * Since the Query class also supports `where` you can continue chaining\n *\n *     User\n *     .where('age').gte(21).lte(65)\n *     .where('name', /^b/i)\n *     ... etc\n *\n * @param {String} path\n * @param {Object} [val] optional value\n * @return {Query}\n * @api public\n */\n\nModel.where = function where (path, val) {\n  var q = new Query().bind(this, 'find');\n  return q.where.apply(q, arguments);\n};\n\n/**\n * Creates a `Query` and specifies a `$where` condition.\n *\n * Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via `find({ $where: javascript })`, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.\n *\n *     Blog.$where('this.comments.length > 5').exec(function (err, docs) {});\n *\n * @param {String|Function} argument is a javascript string or anonymous function\n * @method $where\n * @memberOf Model\n * @return {Query}\n * @see Query.$where #query_Query-%24where\n * @api public\n */\n\nModel.$where = function $where () {\n  var q = new Query().bind(this, 'find');\n  return q.$where.apply(q, arguments);\n};\n\n/**\n * Issues a mongodb findAndModify update command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes immediately if `callback` is passed else a Query object is returned.\n *\n * ####Options:\n *\n * - `new`: bool - true to return the modified document rather than the original. defaults to true\n * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `select`: sets the document fields to return\n *\n * ####Examples:\n *\n *     A.findOneAndUpdate(conditions, update, options, callback) // executes\n *     A.findOneAndUpdate(conditions, update, options)  // returns Query\n *     A.findOneAndUpdate(conditions, update, callback) // executes\n *     A.findOneAndUpdate(conditions, update)           // returns Query\n *     A.findOneAndUpdate()                             // returns Query\n *\n * ####Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * ####Example:\n *\n *     var query = { name: 'borne' };\n *     Model.findOneAndUpdate(query, { name: 'jason borne' }, options, callback)\n *\n *     // is sent as\n *     Model.findOneAndUpdate(query, { $set: { name: 'jason borne' }}, options, callback)\n *\n * This helps prevent accidentally overwriting your document with `{ name: 'jason borne' }`.\n *\n * ####Note:\n *\n * Although values are cast to their appropriate types when using the findAndModify helpers, the following are *not* applied:\n *\n * - defaults\n * - setters\n * - validators\n * - middleware\n *\n * If you need those features, use the traditional approach of first retrieving the document.\n *\n *     Model.findOne({ name: 'borne' }, function (err, doc) {\n *       if (err) ..\n *       doc.name = 'jason borne';\n *       doc.save(callback);\n *     })\n *\n * @param {Object} [conditions]\n * @param {Object} [update]\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query}\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @api public\n */\n\nModel.findOneAndUpdate = function (conditions, update, options, callback) {\n  if ('function' == typeof options) {\n    callback = options;\n    options = null;\n  }\n  else if (1 === arguments.length) {\n    if ('function' == typeof conditions) {\n      var msg = 'Model.findOneAndUpdate(): First argument must not be a function.\\n\\n'\n              + '  ' + this.modelName + '.findOneAndUpdate(conditions, update, options, callback)\\n'\n              + '  ' + this.modelName + '.findOneAndUpdate(conditions, update, options)\\n'\n              + '  ' + this.modelName + '.findOneAndUpdate(conditions, update)\\n'\n              + '  ' + this.modelName + '.findOneAndUpdate(update)\\n'\n              + '  ' + this.modelName + '.findOneAndUpdate()\\n';\n      throw new TypeError(msg)\n    }\n    update = conditions;\n    conditions = undefined;\n  }\n\n  var fields;\n  if (options && options.fields) {\n    fields = options.fields;\n    options.fields = undefined;\n  }\n\n  var query = new Query(conditions);\n  query.setOptions(options);\n  query.select(fields);\n  query.bind(this, 'findOneAndUpdate', update);\n\n  if ('undefined' == typeof callback)\n    return query;\n\n  this._applyNamedScope(query);\n  return query.findOneAndUpdate(callback);\n}\n\n/**\n * Issues a mongodb findAndModify update command by a documents id.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes immediately if `callback` is passed else a Query object is returned.\n *\n * ####Options:\n *\n * - `new`: bool - true to return the modified document rather than the original. defaults to true\n * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `select`: sets the document fields to return\n *\n * ####Examples:\n *\n *     A.findByIdAndUpdate(id, update, options, callback) // executes\n *     A.findByIdAndUpdate(id, update, options)  // returns Query\n *     A.findByIdAndUpdate(id, update, callback) // executes\n *     A.findByIdAndUpdate(id, update)           // returns Query\n *     A.findByIdAndUpdate()                     // returns Query\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes      immediately if `callback` is passed else a Query object is returned.\n *\n * ####Options:\n *\n * - `new`: bool - true to return the modified document rather than the original. defaults to true\n * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n *\n * ####Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * ####Example:\n *\n *     Model.findByIdAndUpdate(id, { name: 'jason borne' }, options, callback)\n *\n *     // is sent as\n *     Model.findByIdAndUpdate(id, { $set: { name: 'jason borne' }}, options, callback)\n *\n * This helps prevent accidentally overwriting your document with `{ name: 'jason borne' }`.\n *\n * ####Note:\n *\n * Although values are cast to their appropriate types when using the findAndModify helpers, the following are *not* applied:\n *\n * - defaults\n * - setters\n * - validators\n * - middleware\n *\n * If you need those features, use the traditional approach of first retrieving the document.\n *\n *     Model.findById(id, function (err, doc) {\n *       if (err) ..\n *       doc.name = 'jason borne';\n *       doc.save(callback);\n *     })\n *\n * @param {ObjectId|HexId} id an ObjectId or string that can be cast to one.\n * @param {Object} [update]\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query}\n * @see Model.findOneAndUpdate #model_Model.findOneAndUpdate\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @api public\n */\n\nModel.findByIdAndUpdate = function (id, update, options, callback) {\n  var args;\n\n  if (1 === arguments.length) {\n    if ('function' == typeof id) {\n      var msg = 'Model.findByIdAndUpdate(): First argument must not be a function.\\n\\n'\n                + '  ' + this.modelName + '.findByIdAndUpdate(id, callback)\\n'\n                + '  ' + this.modelName + '.findByIdAndUpdate(id)\\n'\n                + '  ' + this.modelName + '.findByIdAndUpdate()\\n';\n      throw new TypeError(msg)\n    }\n    return this.findOneAndUpdate({_id: id }, undefined);\n  }\n\n  args = utils.args(arguments, 1);\n  args.unshift({ _id: id });\n  return this.findOneAndUpdate.apply(this, args);\n}\n\n/**\n * Issue a mongodb findAndModify remove command.\n *\n * Finds a matching document, removes it, passing the found document (if any) to the callback.\n *\n * Executes immediately if `callback` is passed else a Query object is returned.\n *\n * ####Options:\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `select`: sets the document fields to return\n *\n * ####Examples:\n *\n *     A.findOneAndRemove(conditions, options, callback) // executes\n *     A.findOneAndRemove(conditions, options)  // return Query\n *     A.findOneAndRemove(conditions, callback) // executes\n *     A.findOneAndRemove(conditions) // returns Query\n *     A.findOneAndRemove()           // returns Query\n *\n * @param {Object} conditions\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query}\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @api public\n */\n\nModel.findOneAndRemove = function (conditions, options, callback) {\n  if (1 === arguments.length && 'function' == typeof conditions) {\n    var msg = 'Model.findOneAndRemove(): First argument must not be a function.\\n\\n'\n              + '  ' + this.modelName + '.findOneAndRemove(conditions, callback)\\n'\n              + '  ' + this.modelName + '.findOneAndRemove(conditions)\\n'\n              + '  ' + this.modelName + '.findOneAndRemove()\\n';\n    throw new TypeError(msg)\n  }\n\n  if ('function' == typeof options) {\n    callback = options;\n    options = undefined;\n  }\n\n  var fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n\n  var query = new Query(conditions);\n  query.setOptions(options);\n  query.select(fields);\n  query.bind(this, 'findOneAndRemove');\n\n  if ('undefined' == typeof callback)\n    return query;\n\n  this._applyNamedScope(query);\n  return query.findOneAndRemove(callback);\n}\n\n/**\n * Issue a mongodb findAndModify remove command by a documents id.\n *\n * Finds a matching document, removes it, passing the found document (if any) to the callback.\n *\n * Executes immediately if `callback` is passed, else a `Query` object is returned.\n *\n * ####Options:\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `select`: sets the document fields to return\n *\n * ####Examples:\n *\n *     A.findByIdAndRemove(id, options, callback) // executes\n *     A.findByIdAndRemove(id, options)  // return Query\n *     A.findByIdAndRemove(id, callback) // executes\n *     A.findByIdAndRemove(id) // returns Query\n *     A.findByIdAndRemove()           // returns Query\n *\n * @param {ObjectId|HexString} id ObjectId or string that can be cast to one\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query}\n * @see Model.findOneAndRemove #model_Model.findOneAndRemove\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n */\n\nModel.findByIdAndRemove = function (id, options, callback) {\n  if (1 === arguments.length && 'function' == typeof id) {\n    var msg = 'Model.findByIdAndRemove(): First argument must not be a function.\\n\\n'\n              + '  ' + this.modelName + '.findByIdAndRemove(id, callback)\\n'\n              + '  ' + this.modelName + '.findByIdAndRemove(id)\\n'\n              + '  ' + this.modelName + '.findByIdAndRemove()\\n';\n    throw new TypeError(msg)\n  }\n\n  return this.findOneAndRemove({ _id: id }, options, callback);\n}\n\n/**\n * Shortcut for creating a new Document that is automatically saved to the db if valid.\n *\n * ####Example:\n *\n *     Candy.create({ type: 'jelly bean' }, { type: 'snickers' }, function (err, jellybean, snickers) {\n *       if (err) // ...\n *     });\n *\n *     var array = [{ type: 'jelly bean' }, { type: 'snickers' }];\n *     Candy.create(array, function (err, jellybean, snickers) {\n *       if (err) // ...\n *     });\n *\n * @param {Array|Object...} doc\n * @param {Function} fn callback\n * @api public\n */\n\nModel.create = function create (doc, fn) {\n  if (1 === arguments.length) {\n    return 'function' === typeof doc && doc(null);\n  }\n\n  var self = this\n    , docs = [null]\n    , promise\n    , count\n    , args\n\n  if (Array.isArray(doc)) {\n    args = doc;\n  } else {\n    args = utils.args(arguments, 0, arguments.length - 1);\n    fn = arguments[arguments.length - 1];\n  }\n\n  if (0 === args.length) return fn(null);\n\n  promise = new Promise(fn);\n  count = args.length;\n\n  args.forEach(function (arg, i) {\n    var doc = new self(arg);\n    docs[i+1] = doc;\n    doc.save(function (err) {\n      if (err) return promise.error(err);\n      --count || fn.apply(null, docs);\n    });\n  });\n\n  // TODO\n  // utilize collection.insertAll for batch processing?\n};\n\n/**\n * Updates documents in the database without returning them.\n *\n * ####Examples:\n *\n *     MyModel.update({ age: { $gt: 18 } }, { oldEnough: true }, fn);\n *     MyModel.update({ name: 'Tobi' }, { ferret: true }, { multi: true }, function (err, numberAffected, raw) {\n *       if (err) return handleError(err);\n *       console.log('The number of updated documents was %d', numberAffected);\n *       console.log('The raw response from Mongo was ', raw);\n *     });\n *\n * ####Valid options:\n *\n *  - `safe` (boolean) safe mode (defaults to value set in schema (true))\n *  - `upsert` (boolean) whether to create the doc if it doesn't match (false)\n *  - `multi` (boolean) whether multiple documents should be updated (false)\n *\n * All `update` values are cast to their appropriate SchemaTypes before being sent.\n *\n * The `callback` function receives `(err, numberAffected, rawResponse)`.\n *\n * - `err` is the error if any occurred\n * - `numberAffected` is the count of updated documents Mongo reported\n * - `rawResponse` is the full response from Mongo\n *\n * ####Note:\n *\n * All top level keys which are not `atomic` operation names are treated as set operations:\n *\n * ####Example:\n *\n *     var query = { name: 'borne' };\n *     Model.update(query, { name: 'jason borne' }, options, callback)\n *\n *     // is sent as\n *     Model.update(query, { $set: { name: 'jason borne' }}, options, callback)\n *\n * This helps prevent accidentally overwriting all documents in your collection with `{ name: 'jason borne' }`.\n *\n * ####Note:\n *\n * To update documents without waiting for a response from MongoDB, do not pass a `callback`, then call `exec` on the returned [Query](#query-js):\n *\n *     Comment.update({ _id: id }, { $set: { text: 'changed' }}).exec();\n *\n * ####Note:\n *\n * Although values are casted to their appropriate types when using update, the following are *not* applied:\n *\n * - defaults\n * - setters\n * - validators\n * - middleware\n *\n * If you need those features, use the traditional approach of first retrieving the document.\n *\n *     Model.findOne({ name: 'borne' }, function (err, doc) {\n *       if (err) ..\n *       doc.name = 'jason borne';\n *       doc.save(callback);\n *     })\n *\n * @param {Object} conditions\n * @param {Object} update\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.update = function update (conditions, doc, options, callback) {\n  if (arguments.length < 4) {\n    if ('function' === typeof options) {\n      // Scenario: update(conditions, doc, callback)\n      callback = options;\n      options = null;\n    } else if ('function' === typeof doc) {\n      // Scenario: update(doc, callback);\n      callback = doc;\n      doc = conditions;\n      conditions = {};\n      options = null;\n    }\n  }\n\n  var query = new Query(conditions, options).bind(this, 'update', doc);\n\n  if ('undefined' == typeof callback)\n    return query;\n\n  this._applyNamedScope(query);\n  return query.update(doc, callback);\n};\n\n/**\n * Executes a mapReduce command.\n *\n * `o` is an object specifying all mapReduce options as well as the map and reduce functions. All options are delegated to the driver implementation.\n *\n * ####Example:\n *\n *     var o = {};\n *     o.map = function () { emit(this.name, 1) }\n *     o.reduce = function (k, vals) { return vals.length }\n *     User.mapReduce(o, function (err, results) {\n *       console.log(results)\n *     })\n *\n * ####Other options:\n *\n * - `query` {Object} query filter object.\n * - `limit` {Number} max number of documents\n * - `keeptemp` {Boolean, default:false} keep temporary data\n * - `finalize` {Function} finalize function\n * - `scope` {Object} scope variables exposed to map/reduce/finalize during execution\n * - `jsMode` {Boolean, default:false} it is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X\n * - `verbose` {Boolean, default:false} provide statistics on job execution time.\n * - `out*` {Object, default: {inline:1}} sets the output target for the map reduce job.\n *\n * ####* out options:\n *\n * - `{inline:1}` the results are returned in an array\n * - `{replace: 'collectionName'}` add the results to collectionName: the results replace the collection\n * - `{reduce: 'collectionName'}` add the results to collectionName: if dups are detected, uses the reducer / finalize functions\n * - `{merge: 'collectionName'}` add the results to collectionName: if dups exist the new docs overwrite the old\n *\n * If `options.out` is set to `replace`, `merge`, or `reduce`, a Model instance is returned that can be used for further querying. Queries run against this model are all executed with the `lean` option; meaning only the js object is returned and no Mongoose magic is applied (getters, setters, etc).\n *\n * ####Example:\n *\n *     var o = {};\n *     o.map = function () { emit(this.name, 1) }\n *     o.reduce = function (k, vals) { return vals.length }\n *     o.out = { replace: 'createdCollectionNameForResults' }\n *     o.verbose = true;\n *     User.mapReduce(o, function (err, model, stats) {\n *       console.log('map reduce took %d ms', stats.processtime)\n *       model.find().where('value').gt(10).exec(function (err, docs) {\n *         console.log(docs);\n *       });\n *     })\n *\n * @param {Object} o an object specifying map-reduce options\n * @param {Function} callback\n * @see http://www.mongodb.org/display/DOCS/MapReduce\n * @api public\n */\n\nModel.mapReduce = function mapReduce (o, callback) {\n  if ('function' != typeof callback) throw new Error('missing callback');\n\n  var self = this;\n\n  if (!Model.mapReduce.schema) {\n    var opts = { noId: true, noVirtualId: true, strict: false }\n    Model.mapReduce.schema = new Schema({}, opts);\n  }\n\n  if (!o.out) o.out = { inline: 1 };\n\n  o.map = String(o.map);\n  o.reduce = String(o.reduce);\n\n  if (o.query) {\n    var q = new Query(o.query);\n    q.cast(this);\n    o.query = q._conditions;\n    q = undefined;\n  }\n\n  this.collection.mapReduce(null, null, o, function (err, ret, stats) {\n    if (err) return callback(err);\n\n    if (ret.findOne && ret.mapReduce) {\n      // returned a collection, convert to Model\n      var model = Model.compile(\n          '_mapreduce_' + ret.collectionName\n        , Model.mapReduce.schema\n        , ret.collectionName\n        , self.db\n        , self.base);\n\n      model._mapreduce = true;\n\n      return callback(err, model, stats);\n    }\n\n    callback(err, ret, stats);\n  });\n}\n\n/**\n * Executes an aggregate command on this models collection.\n *\n * ####Example:\n *\n *     // find the max age of all users\n *     Users.aggregate(\n *         { $group: { _id: null, maxAge: { $max: '$age' }}}\n *       , { $project: { _id: 0, maxAge: 1 }}\n *       , function (err, res) {\n *       if (err) return handleError(err);\n *       console.log(res); // [ { maxAge: 98 } ]\n *     });\n *\n * _NOTE: the documents returned are plain javascript objects, not mongoose documents cast to this models schema definition (since any shape of document can be returned)._\n *\n * _NOTE: this requires running MongoDB >= 2.1_\n *\n * @param {Array} array an array of pipeline commands\n * @param {Object} [options]\n * @param {Function} callback\n * @see aggregation http://docs.mongodb.org/manual/applications/aggregation/\n * @see driver http://mongodb.github.com/node-mongodb-native/api-generated/collection.html#aggregate\n * @api public\n */\n\nModel.aggregate = function aggregate () {\n  return this.collection.aggregate.apply(this.collection, arguments);\n}\n\n/*!\n * Compiler utility.\n *\n * @param {String} name model name\n * @param {Schema} schema\n * @param {String} collectionName\n * @param {Connection} connection\n * @param {Mongoose} base mongoose instance\n */\n\nModel.compile = function compile (name, schema, collectionName, connection, base) {\n  // generate new class\n  function model (doc, fields, skipId) {\n    if (!(this instanceof model))\n      return new model(doc, fields, skipId);\n    Model.call(this, doc, fields, skipId);\n  };\n\n  model.modelName = name;\n  model.__proto__ = Model;\n  model.prototype.__proto__ = Model.prototype;\n  model.prototype.db = connection;\n  model.prototype._setSchema(schema);\n  model.prototype.collection = connection.collection(\n      collectionName\n    , schema.options.capped\n  );\n\n  // apply methods\n  for (var i in schema.methods)\n    model.prototype[i] = schema.methods[i];\n\n  // apply statics\n  for (var i in schema.statics)\n    model[i] = schema.statics[i];\n\n  // apply named scopes\n  if (schema.namedScopes) schema.namedScopes.compile(model);\n\n  model.model = model.prototype.model;\n  model.options = model.prototype.options;\n  model.db = model.prototype.db;\n  model.schema = model.prototype.schema;\n  model.collection = model.prototype.collection;\n  model.base = base;\n\n  return model;\n};\n\n/*!\n * Subclass this model with `conn`, `schema`, and `collection` settings.\n *\n * @param {Connection} conn\n * @param {Schema} [schema]\n * @param {String} [collection]\n * @return {Model}\n */\n\nModel.__subclass = function subclass (conn, schema, collection) {\n  // subclass model using this connection and collection name\n  var model = this;\n\n  var Model = function Model (doc, fields, skipId) {\n    if (!(this instanceof Model)) {\n      return new Model(doc, fields, skipId);\n    }\n    model.call(this, doc, fields, skipId);\n  }\n\n  Model.__proto__ = model;\n  Model.prototype.__proto__ = model.prototype;\n  Model.db = Model.prototype.db = conn;\n\n  var s = 'string' != typeof schema\n    ? schema\n    : model.prototype.schema;\n\n  if (!collection) {\n    collection = model.prototype.schema.get('collection')\n              || utils.toCollectionName(model.modelName);\n  }\n\n  Model.prototype.collection = conn.collection(collection, s && s.options.capped);\n  Model.collection = Model.prototype.collection;\n  Model.init();\n  return Model;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Model;\n"]],"start1":0,"start2":0,"length1":0,"length2":50406}]],"length":50406}
