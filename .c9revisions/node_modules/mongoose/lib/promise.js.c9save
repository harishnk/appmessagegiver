{"ts":1363486902191,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n/*!\n * Module dependencies.\n */\n\nvar util = require('./utils');\nvar EventEmitter = require('events').EventEmitter;\n\n/**\n * Promise constructor.\n *\n * @param {Function} back a callback+errback that accepts `fn(err, ...){}` as signature\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `err`: Emits when the promise resolves to an error.\n * @event `complete`: Emits when the promise resolves sucessfully.\n * @api public\n */\n\nfunction Promise (back) {\n  this.emitted = {};\n  if ('function' == typeof back)\n    this.addBack(back);\n};\n\n/*!\n * Inherits from EventEmitter.\n */\n\nPromise.prototype.__proto__ = EventEmitter.prototype;\n\n/**\n * Adds `listener` to the `event`.\n *\n * If `event` is either `error` or `complete` and the event has already been emitted, the`listener` is called immediately and passed the results of the original emitted event.\n *\n * @param {String} event\n * @param {Function} callback\n * @return {Promise} this\n * @api public\n */\n\nPromise.prototype.on = function (event, callback) {\n  if (this.emitted[event])\n    callback.apply(this, this.emitted[event]);\n  else\n    EventEmitter.prototype.on.call(this, event, callback);\n\n  return this;\n};\n\n/**\n * Keeps track of emitted events to run them on `on`.\n *\n * @api private\n */\n\nPromise.prototype.emit = function (event) {\n  // ensures a promise can't be complete() or error() twice\n  if (event == 'err' || event == 'complete'){\n    if (this.emitted.err || this.emitted.complete) {\n      return this;\n    }\n    this.emitted[event] = util.args(arguments, 1);\n  }\n\n  return EventEmitter.prototype.emit.apply(this, arguments);\n};\n\n/**\n * Shortcut for emitting the `complete` event.\n *\n * @api public\n */\n\nPromise.prototype.complete = function () {\n  var args = util.args(arguments);\n  return this.emit.apply(this, ['complete'].concat(args));\n};\n\n/**\n * Shortcut for emitting the `err` event.\n *\n * If `err` is not instanceof Error, it is cast to Error before rejecting.\n *\n * @api public\n * @return {Promise}\n */\n\nPromise.prototype.error = function (err) {\n  if (!(err instanceof Error)) err = new Error(err);\n  return this.emit('err', err);\n};\n\n/**\n * Adds a listener to the `complete` (success) event.\n *\n * @return {Promise} this\n * @api public\n */\n\nPromise.prototype.addCallback = function (fn) {\n  return this.on('complete', fn);\n};\n\n/**\n * Adds a listener to the `err` (rejected) event.\n *\n * @return {Promise} this\n * @api public\n */\n\nPromise.prototype.addErrback = function (fn) {\n  return this.on('err', fn);\n};\n\n/**\n * Adds a single function as both a callback and errback.\n *\n * It will be executed with traditional node.js argument position:\n * function (err, args...) {}\n *\n * @param {Function} fn\n * @return {Promise} this\n */\n\nPromise.prototype.addBack = function (fn) {\n  this.on('err', function(err){\n    fn.call(this, err);\n  });\n\n  this.on('complete', function(){\n    var args = util.args(arguments);\n    fn.apply(this, [null].concat(args));\n  });\n\n  return this;\n};\n\n/**\n * Resolves this promise to an error state if `err` is passed or success state when no `err` is passed.\n *\n * `err` will be cast to an Error if not already instanceof Error.\n *\n * @param {Error} [err] error or null\n * @param {Object} [val] value to complete the promise with\n * @api public\n */\n\nPromise.prototype.resolve = function (err, val) {\n  if (err) return this.error(err);\n  return this.complete(val);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = Promise;\n"]],"start1":0,"start2":0,"length1":0,"length2":3480}]],"length":3480}
