{"ts":1363486796851,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\nvar domain = require('domain');\nvar EventEmitter = require('events').EventEmitter;\nvar http = require('http');\nvar https = require('https');\nvar url = require('url');\nvar util = require('util');\n\nvar assert = require('assert-plus');\nvar mime = require('mime');\nvar once = require('once');\nvar spdy = require('spdy');\n\nvar dtrace = require('./dtrace');\nvar errors = require('./errors');\nvar formatters = require('./formatters');\nvar shallowCopy = require('./utils').shallowCopy;\n\nvar semver = require('semver');\nvar maxSatisfying = semver.maxSatisfying;\n\n// Ensure these are loaded\nrequire('./request');\nrequire('./response');\n\n\n\n///--- Globals\n\nvar sprintf = util.format;\n\nvar BadMethodError = errors.BadMethodError;\nvar InvalidVersionError = errors.InvalidVersionError;\nvar ResourceNotFoundError = errors.ResourceNotFoundError;\n\nvar PROXY_EVENTS = [\n        'clientError',\n        'close',\n        'connection',\n        'error',\n        'listening',\n        'secureConnection',\n        'upgrade'\n];\n\n\n\n///--- Helpers\n\nfunction argumentsToChain(args, start) {\n        assert.ok(args);\n\n        args = Array.prototype.slice.call(args, start);\n\n        if (args.length < 0)\n                throw new TypeError('handler (function) required');\n\n        var chain = [];\n\n        function process(handlers) {\n                for (var i = 0; i < handlers.length; i++) {\n                        if (Array.isArray(handlers[i])) {\n                                process(handlers[i], 0);\n                        } else {\n                                assert.func(handlers[i], 'handler');\n                                chain.push(handlers[i]);\n                        }\n                }\n\n                return (chain);\n        }\n\n        return (process(args));\n}\n\n\nfunction mergeFormatters(fmt) {\n        var arr = [];\n        var defaults = Object.keys(formatters).length;\n        var i = 0;\n        var obj = {};\n\n        function addFormatter(src, k) {\n                assert.func(src[k], 'formatter');\n\n                var q;\n                var t = k;\n                if (k.indexOf(';') !== -1) {\n                        /* JSSTYLED */\n                        var tmp = k.split(/\\s*;\\s*/);\n                        t = tmp[0];\n                        if (tmp[1].indexOf('q=') !== -1) {\n                                q = parseFloat(tmp[1].split('=')[1], 10) * 10;\n                        }\n                }\n\n                if (k.indexOf('/') === -1)\n                        k = mime.lookup(k);\n\n                obj[t] = src[k];\n                arr.push({\n                        q: q || (i + defaults),\n                        t: t\n                });\n                i++;\n        }\n\n        Object.keys(formatters).forEach(addFormatter.bind(this, formatters));\n        Object.keys(fmt || {}).forEach(addFormatter.bind(this, fmt || {}));\n\n        arr = arr.sort(function (a, b) {\n                return (b.q - a.q);\n        }).map(function (a) {\n                return (a.t);\n        });\n\n        return ({\n                formatters: obj,\n                acceptable: arr\n        });\n}\n\n\n\n///--- API\n\nfunction Server(options) {\n        assert.object(options, 'options');\n        assert.object(options.log, 'options.log');\n        assert.object(options.router, 'options.router');\n\n        var self = this;\n\n        EventEmitter.call(this);\n\n        this.before = [];\n        this.chain = [];\n        this.log = options.log;\n        this.name = options.name || 'restify';\n        this.router = options.router;\n        this.routes = {};\n        this.secure = false;\n        this.versions = options.versions || options.version || [];\n\n        var fmt = mergeFormatters(options.formatters);\n        this.acceptable = fmt.acceptable;\n        this.formatters = fmt.formatters;\n\n        if (options.spdy) {\n                this.spdy = true;\n                this.server = spdy.createServer(options.spdy);\n        } else if ((options.cert || options.certificate) && options.key) {\n                this.ca = options.ca;\n                this.certificate = options.certificate || options.cert;\n                this.key = options.key;\n                this.passphrase = options.passphrase || null;\n                this.secure = true;\n\n                this.server = https.createServer({\n                        ca: self.ca,\n                        cert: self.certificate,\n                        key: self.key,\n                        passphrase: self.passphrase,\n                        rejectUnauthorized: options.rejectUnauthorized,\n                        requestCert: options.requestCert\n                });\n        } else {\n                this.server = http.createServer();\n        }\n\n        this.router.on('mount', this.emit.bind(this, 'mount'));\n\n        PROXY_EVENTS.forEach(function (e) {\n                self.server.on(e, self.emit.bind(self, e));\n        });\n\n        // Now the things we can't blindly proxy\n        this.server.on('checkContinue', function onCheckContinue(req, res) {\n                if (self.listeners('checkContinue').length > 0) {\n                        self.emit('checkContinue', req, res);\n                        return;\n                }\n\n                if (!options.noWriteContinue)\n                        res.writeContinue();\n\n                self._setupRequest(req, res);\n                self._handle(req, res, true);\n        });\n\n        this.server.on('request', function onRequest(req, res) {\n                /* JSSTYLED */\n                if (/^\\/socket.io.*/.test(req.url) &&\n                    self.listeners('request').length > 0) {\n                        self.emit('request', req, res);\n                        return;\n                }\n\n                self._setupRequest(req, res);\n                self._handle(req, res);\n        });\n\n        this.__defineGetter__('maxHeadersCount', function () {\n                return (self.server.maxHeadersCount);\n        });\n\n        this.__defineSetter__('maxHeadersCount', function (c) {\n                self.server.maxHeadersCount = c;\n                return (c);\n        });\n\n\n        this.__defineGetter__('url', function () {\n                if (self.socketPath)\n                        return ('http://' + self.socketPath);\n\n                var addr = self.address();\n                var str = '';\n                if (self.spdy) {\n                        str += 'spdy://';\n                } else if (self.secure) {\n                        str += 'https://';\n                } else {\n                        str += 'http://';\n                }\n\n                if (addr) {\n                        str += addr.address;\n                        str += ':';\n                        str += addr.port;\n                } else {\n                        str += '169.254.0.1:0000';\n                }\n\n                return (str);\n        });\n}\nutil.inherits(Server, EventEmitter);\nmodule.exports = Server;\n\n\nServer.prototype.address = function address() {\n        return (this.server.address());\n};\n\n/**\n * Gets the server up and listening.\n *\n * You can call like:\n *  server.listen(80)\n *  server.listen(80, '127.0.0.1')\n *  server.listen('/tmp/server.sock')\n *\n * @param {Function} callback optionally get notified when listening.\n * @throws {TypeError} on bad input.\n */\nServer.prototype.listen = function listen() {\n        var args = Array.prototype.slice.call(arguments);\n        return (this.server.listen.apply(this.server, args));\n};\n\n\n/**\n * Shuts down this server, and invokes callback (optionally) when done.\n *\n * @param {Function} callback optional callback to invoke when done.\n */\nServer.prototype.close = function close(callback) {\n        if (callback)\n                assert.func(callback, 'callback');\n\n        this.server.once('close', function onClose() {\n                return (callback ? callback() : false);\n        });\n\n        return (this.server.close());\n};\n\n\n// Register all the routing methods\n/**\n * Mounts a chain on the given path against this HTTP verb\n *\n * @param {Object} options the URL to handle, at minimum.\n * @return {Route} the newly created route.\n */\n[\n        'del',\n        'get',\n        'head',\n        'opts',\n        'post',\n        'put',\n        'patch'\n].forEach(function (method) {\n        Server.prototype[method] = function (opts) {\n                if (opts instanceof RegExp || typeof (opts) === 'string') {\n                        opts = {\n                                path: opts\n                        };\n                } else if (typeof (opts) === 'object') {\n                        opts = shallowCopy(opts);\n                } else {\n                        throw new TypeError('path (string) required');\n                }\n\n                if (arguments.length < 2)\n                        throw new TypeError('handler (function) required');\n\n                var chain = [];\n                var route;\n                var self = this;\n\n                function addHandler(h) {\n                        assert.func(h, 'handler');\n\n                        chain.push(h);\n                }\n\n                if (method === 'del')\n                        method = 'DELETE';\n                if (method === 'opts')\n                        method = 'OPTIONS';\n                opts.method = method.toUpperCase();\n                opts.versions = opts.versions || opts.version || self.versions;\n                if (!Array.isArray(opts.versions))\n                        opts.versions = [opts.versions];\n\n                if (!opts.name) {\n                        opts.name = method + '-' + (opts.path || opts.url);\n                        if (opts.versions.length > 0) {\n                                opts.name += '-' + opts.versions.join('--');\n                        }\n                }\n                opts.name = opts.name.replace(/\\W/g, '').toLowerCase();\n\n                if (!(route = this.router.mount(opts)))\n                        return (false);\n\n                this.chain.forEach(addHandler);\n                argumentsToChain(arguments, 1).forEach(addHandler);\n                this.routes[route] = chain;\n\n                return (route);\n        };\n});\n\n\n/**\n * Minimal port of the functionality offered by Express.js Route Param\n * Pre-conditions\n * @link http://expressjs.com/guide.html#route-param%20pre-conditions\n *\n * This basically piggy-backs on the `server.use` method. It attaches a\n * new middleware function that only fires if the specified parameter exists\n * in req.params\n *\n * Exposes an API:\n *   server.param(\"user\", function (req, res, next) {\n *     // load the user's information here, always making sure to call next()\n *   });\n *\n * @param {String} The name of the URL param to respond to\n * @param {Function} The middleware function to execute\n */\nServer.prototype.param = function param(name, fn) {\n        this.use(function _param(req, res, next) {\n                if (req.params && req.params[name]) {\n                        fn.call(this, req, res, next, req.params[name], name);\n                } else {\n                        next();\n                }\n        });\n\n        return (this);\n};\n\n\n/**\n * Piggy-backs on the `server.use` method. It attaches a new middleware\n * function that only fires if the specified version matchtes the request.\n *\n * Note that if the client does not request a specific version, the middleware\n * function always fires. If you don't want this set a default version with a\n * pre handler on requests where the client omits one.\n *\n * Exposes an API:\n *   server.versionedUse(\"version\", function (req, res, next, ver) {\n *     // do stuff that only applies to routes of this API version\n *   });\n *\n * @param {String|Array} The version or versions of the URL to respond to\n * @param {Function} The middleware function to execute, the fourth parameter\n *                   will be the selected version\n */\nServer.prototype.versionedUse = function versionedUse(versions, fn) {\n        if (!Array.isArray(versions))\n                versions = [versions];\n        assert.arrayOfString(versions, 'versions');\n\n        versions.forEach(function (v) {\n                if (!semver.valid(v))\n                        throw new TypeError('%s is not a valid semver', v);\n        });\n\n        this.use(function _versionedUse(req, res, next) {\n                var ver;\n                if (req.version() === '*' ||\n                    (ver = maxSatisfying(versions,\n                                         req.version()) || false)) {\n                        fn.call(this, req, res, next, ver);\n                } else {\n                        next();\n                }\n        });\n\n        return (this);\n};\n\n\n/**\n * Removes a route from the server.\n *\n * You  pass in the route 'blob' you got from a mount call.\n *\n * @param {String} name the route name.\n * @return {Boolean} true if route was removed, false if not.\n * @throws {TypeError} on bad input.\n */\nServer.prototype.rm = function rm(route) {\n        var r = this.router.unmount(route);\n        if (r && this.routes[r])\n                delete this.routes[r];\n\n        return (r);\n};\n\n\n/**\n * Installs a list of handlers to run _before_ the \"normal\" handlers of all\n * routes.\n *\n * You can pass in any combination of functions or array of functions.\n *\n * @throws {TypeError} on input error.\n */\nServer.prototype.use = function use() {\n        var self = this;\n\n        (argumentsToChain(arguments) || []).forEach(function (h) {\n                self.chain.push(h);\n        });\n\n        return (this);\n};\n\n\n/**\n * Gives you hooks to run _before_ any routes are located.  This gives you\n * a chance to intercept the request and change headers, etc., that routing\n * depends on.  Note that req.params will _not_ be set yet.\n */\nServer.prototype.pre = function pre() {\n        var self = this;\n\n        argumentsToChain(arguments).forEach(function (h) {\n                self.before.push(h);\n        });\n\n        return (this);\n};\n\n\nServer.prototype.toString = function toString() {\n        var LINE_FMT = '\\t%s: %s\\n';\n        var SUB_LINE_FMT = '\\t\\t%s: %s\\n';\n        var self = this;\n        var str = '';\n\n        function handlersToString(arr) {\n                var s = '[' + arr.map(function (b) {\n                        return (b.name || 'function');\n                }).join(', ') + ']';\n\n                return (s);\n        }\n\n        str += sprintf(LINE_FMT, 'Accepts', this.acceptable.join(', '));\n        str += sprintf(LINE_FMT, 'Name', this.name);\n        str += sprintf(LINE_FMT, 'Pre', handlersToString(this.before));\n        str += sprintf(LINE_FMT, 'Router', this.router.toString());\n        str += sprintf(LINE_FMT, 'Routes:', '');\n        Object.keys(this.routes).forEach(function (k) {\n                var handlers = handlersToString(self.routes[k]);\n                str += sprintf(SUB_LINE_FMT, k, handlers);\n        });\n        str += sprintf(LINE_FMT, 'Secure', this.secure);\n        str += sprintf(LINE_FMT, 'Url', this.url);\n        str += sprintf(LINE_FMT, 'Version', this.version.join());\n\n        return (str);\n};\n\n\n\n///--- Private methods\n\nServer.prototype._handle = function _handle(req, res) {\n        var log = this.log;\n        var self = this;\n\n        function _route() {\n                if (log.trace()) {\n                        log.trace({\n                                req: req,\n                                req_id: req.getId()\n                        }, 'checking for route');\n                }\n\n                function emitRouteError(name, err) {\n                        if (self.listeners(name).length > 0) {\n                                self.emit(name, req, res, once(function () {\n                                        self.emit('after', req, res, null);\n                                }));\n                        } else {\n                                res.send(err);\n                                self.emit('after', req, res, null);\n                        }\n                }\n\n                self.router.find(req, res, function onRoute(err, route, ctx) {\n                        var r = route ? route.name : null;\n                        if (err) {\n                                if (err.statusCode === 404 &&\n                                    req.method === 'OPTIONS' &&\n                                    req.url === '*') {\n                                        res.send(200);\n                                        self.emit('after', req, res, null);\n                                        return;\n                                }\n                                log.trace({\n                                        err: err,\n                                        req_id: req.getId()\n                                }, 'router errored out');\n\n                                switch (err.name) {\n                                case 'ResourceNotFoundError':\n                                        emitRouteError('NotFound', err);\n                                        break;\n\n                                case 'MethodNotAllowedError':\n                                        emitRouteError('MethodNotAllowed',\n                                                       err);\n                                        break;\n\n                                case 'InvalidVersionError':\n                                        emitRouteError('VersionNotAllowed',\n                                                       err);\n                                        break;\n\n                                case 'UnsupportedMediaTypeError':\n                                        emitRouteError('UnsupportedMediaType',\n                                                       err);\n                                        break;\n\n                                default:\n                                        emitRouteError(' ', err);\n                                        break;\n                                }\n                        } else if (r === true) {\n                                // this probably indicates a preflight request\n                                // at any rate semantic means return 200\n                                res.send(200);\n                                self.emit('after', req, res, null);\n                        } else if (!r || !self.routes[r]) {\n                                log.trace({\n                                        req_id: req.getId()\n                                }, 'no route found (null route)');\n                                emitRouteError('NotFound', 404);\n                        } else {\n                                if (log.trace()) {\n                                        log.trace({\n                                                req_id: req.getId(),\n                                                route: r\n                                        }, 'route found');\n                                }\n\n                                req.context = req.params = ctx;\n                                req.route = route.spec;\n                                var chain = self.routes[r];\n                                self._run(req, res, r, chain, function done(e) {\n                                        self.emit('after', req, res, r, e);\n                                });\n                        }\n                });\n        }\n\n        // We need to check if should run the _pre_ chain first.\n        if (this.before.length > 0) {\n                if (log.trace())\n                        log.trace({req: req}, 'running pre chain');\n\n                this._run(req, res, null, this.before, function (err) {\n                        if (err) {\n                                log.trace({\n                                        err: err\n                                }, 'pre chain errored out. Done.');\n                                return (false);\n                        }\n\n                        return (_route());\n                });\n                return (false);\n        }\n\n        return (_route());\n};\n\n\nServer.prototype._run = function _run(req, res, route, chain, callback) {\n        var d;\n        var i = -1;\n        var id = dtrace.nextId();\n        var log = this.log;\n        var self = this;\n\n        function ifError(n) {\n                function _ifError(err) {\n                        if (err) {\n                                err._restify_next = n;\n                                throw err;\n                        }\n                }\n                return (_ifError);\n        }\n\n        function next(err) {\n                // The goofy checks here are to make sure we fire the DTrace\n                // probes after an error might have been sent, as in a handler\n                // return next(new Error) is basically shorthand for sending an\n                // error via res.send(), so we do that before firing the dtrace\n                // probe (namely so the status codes get updated in the\n                // response).\n                var done = false;\n                if (err) {\n                        if (log.trace())\n                                log.trace({err: err}, 'next(err=%s)',\n                                          err.name || 'Error');\n                        res.send(err);\n                        done = true;\n                }\n\n                // Callers can stop the chain from proceding if they do\n                // return next(false); This is useful for non-errors, but where\n                // a response was sent and you don't want the chain to keep\n                // going\n                if (err === false)\n                        done = true;\n\n                // Fire DTrace done for the previous handler.\n                if ((i + 1) > 0 && chain[i]) {\n                        dtrace._rstfy_probes['handler-done'].fire(function () {\n                                return ([\n                                        self.name,\n                                        route !== null ? route : 'pre',\n                                        chain[i].name || ('handler-' + i),\n                                        id\n                                ]);\n                        });\n                }\n\n                // Run the next handler up\n                if (!done && chain[++i]) {\n                        if (log.trace())\n                                log.trace('running %s', chain[i].name || '?');\n\n                        dtrace._rstfy_probes['handler-start'].fire(function () {\n                                return ([\n                                        self.name,\n                                        route !== null ? route : 'pre',\n                                        chain[i].name || ('handler-' + i),\n                                        id\n                                ]);\n                        });\n\n                        var n = once(next);\n                        n.ifError = ifError(n);\n                        return (chain[i].call(self, req, res, n));\n                }\n\n                dtrace._rstfy_probes['route-done'].fire(function () {\n                        return ([\n                                self.name,\n                                route !== null ? route : 'pre',\n                                id,\n                                res.statusCode || 200,\n                                res.headers()\n                        ]);\n                });\n\n                if (route === null) {\n                        self.emit('preDone', req, res);\n                } else {\n                        self.emit('done', req, res, route);\n                }\n\n                return (callback ? callback(err) : true);\n        }\n        var n1 = once(next);\n        n1.ifError = ifError(n1);\n\n        dtrace._rstfy_probes['route-start'].fire(function () {\n                return ([\n                        self.name,\n                        route !== null ? route : 'pre',\n                        id,\n                        req.method,\n                        req.href(),\n                        req.headers\n                ]);\n        });\n\n        d = domain.create();\n        d.add(req);\n        d.add(res);\n        d.on('error', function onError(err) {\n                if (err._restify_next) {\n                        err._restify_next(err);\n                } else {\n                        log.trace({err: err}, 'uncaughtException');\n                        self.emit('uncaughtException', req, res, route, err);\n                }\n        });\n        d.run(n1);\n};\n\n\nServer.prototype._setupRequest = function _setupRequest(req, res) {\n        req.log = res.log = this.log;\n        req._time = res._time = Date.now();\n\n        res.acceptable = this.acceptable;\n        res.formatters = this.formatters;\n        res.req = req;\n        res.serverName = this.name;\n        res.version = this.router.versions[this.router.versions.length - 1];\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":24831}]],"length":24831}
